{"version":3,"file":"static/js/lezer-vendor.8eafcbaa.js","mappings":"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","sources":["../node_modules/@lezer/common/dist/index.js","../node_modules/@lezer/lr/dist/index.js","../node_modules/@lezer/json/dist/index.es.js"],"sourcesContent":["// FIXME profile adding a per-Tree TreeNode cache, validating it by\n// parent pointer\n/// The default maximum length of a `TreeBuffer` node (1024).\nconst DefaultBufferLength = 1024;\nlet nextPropID = 0;\nclass Range {\n    constructor(from, to) {\n        this.from = from;\n        this.to = to;\n    }\n}\n/// Each [node type](#common.NodeType) or [individual tree](#common.Tree)\n/// can have metadata associated with it in props. Instances of this\n/// class represent prop names.\nclass NodeProp {\n    /// Create a new node prop type.\n    constructor(config = {}) {\n        this.id = nextPropID++;\n        this.perNode = !!config.perNode;\n        this.deserialize = config.deserialize || (() => {\n            throw new Error(\"This node type doesn't define a deserialize function\");\n        });\n    }\n    /// This is meant to be used with\n    /// [`NodeSet.extend`](#common.NodeSet.extend) or\n    /// [`LRParser.configure`](#lr.ParserConfig.props) to compute\n    /// prop values for each node type in the set. Takes a [match\n    /// object](#common.NodeType^match) or function that returns undefined\n    /// if the node type doesn't get this prop, and the prop's value if\n    /// it does.\n    add(match) {\n        if (this.perNode)\n            throw new RangeError(\"Can't add per-node props to node types\");\n        if (typeof match != \"function\")\n            match = NodeType.match(match);\n        return (type) => {\n            let result = match(type);\n            return result === undefined ? null : [this, result];\n        };\n    }\n}\n/// Prop that is used to describe matching delimiters. For opening\n/// delimiters, this holds an array of node names (written as a\n/// space-separated string when declaring this prop in a grammar)\n/// for the node types of closing delimiters that match it.\nNodeProp.closedBy = new NodeProp({ deserialize: str => str.split(\" \") });\n/// The inverse of [`closedBy`](#common.NodeProp^closedBy). This is\n/// attached to closing delimiters, holding an array of node names\n/// of types of matching opening delimiters.\nNodeProp.openedBy = new NodeProp({ deserialize: str => str.split(\" \") });\n/// Used to assign node types to groups (for example, all node\n/// types that represent an expression could be tagged with an\n/// `\"Expression\"` group).\nNodeProp.group = new NodeProp({ deserialize: str => str.split(\" \") });\n/// The hash of the [context](#lr.ContextTracker.constructor)\n/// that the node was parsed in, if any. Used to limit reuse of\n/// contextual nodes.\nNodeProp.contextHash = new NodeProp({ perNode: true });\n/// The distance beyond the end of the node that the tokenizer\n/// looked ahead for any of the tokens inside the node. (The LR\n/// parser only stores this when it is larger than 25, for\n/// efficiency reasons.)\nNodeProp.lookAhead = new NodeProp({ perNode: true });\n/// This per-node prop is used to replace a given node, or part of a\n/// node, with another tree. This is useful to include trees from\n/// different languages.\nNodeProp.mounted = new NodeProp({ perNode: true });\n/// A mounted tree, which can be [stored](#common.NodeProp^mounted) on\n/// a tree node to indicate that parts of its content are\n/// represented by another tree.\nclass MountedTree {\n    constructor(\n    /// The inner tree.\n    tree, \n    /// If this is null, this tree replaces the entire node (it will\n    /// be included in the regular iteration instead of its host\n    /// node). If not, only the given ranges are considered to be\n    /// covered by this tree. This is used for trees that are mixed in\n    /// a way that isn't strictly hierarchical. Such mounted trees are\n    /// only entered by [`resolveInner`](#common.Tree.resolveInner)\n    /// and [`enter`](#common.SyntaxNode.enter).\n    overlay, \n    /// The parser used to create this subtree.\n    parser) {\n        this.tree = tree;\n        this.overlay = overlay;\n        this.parser = parser;\n    }\n}\nconst noProps = Object.create(null);\n/// Each node in a syntax tree has a node type associated with it.\nclass NodeType {\n    /// @internal\n    constructor(\n    /// The name of the node type. Not necessarily unique, but if the\n    /// grammar was written properly, different node types with the\n    /// same name within a node set should play the same semantic\n    /// role.\n    name, \n    /// @internal\n    props, \n    /// The id of this node in its set. Corresponds to the term ids\n    /// used in the parser.\n    id, \n    /// @internal\n    flags = 0) {\n        this.name = name;\n        this.props = props;\n        this.id = id;\n        this.flags = flags;\n    }\n    static define(spec) {\n        let props = spec.props && spec.props.length ? Object.create(null) : noProps;\n        let flags = (spec.top ? 1 /* Top */ : 0) | (spec.skipped ? 2 /* Skipped */ : 0) |\n            (spec.error ? 4 /* Error */ : 0) | (spec.name == null ? 8 /* Anonymous */ : 0);\n        let type = new NodeType(spec.name || \"\", props, spec.id, flags);\n        if (spec.props)\n            for (let src of spec.props) {\n                if (!Array.isArray(src))\n                    src = src(type);\n                if (src) {\n                    if (src[0].perNode)\n                        throw new RangeError(\"Can't store a per-node prop on a node type\");\n                    props[src[0].id] = src[1];\n                }\n            }\n        return type;\n    }\n    /// Retrieves a node prop for this type. Will return `undefined` if\n    /// the prop isn't present on this node.\n    prop(prop) { return this.props[prop.id]; }\n    /// True when this is the top node of a grammar.\n    get isTop() { return (this.flags & 1 /* Top */) > 0; }\n    /// True when this node is produced by a skip rule.\n    get isSkipped() { return (this.flags & 2 /* Skipped */) > 0; }\n    /// Indicates whether this is an error node.\n    get isError() { return (this.flags & 4 /* Error */) > 0; }\n    /// When true, this node type doesn't correspond to a user-declared\n    /// named node, for example because it is used to cache repetition.\n    get isAnonymous() { return (this.flags & 8 /* Anonymous */) > 0; }\n    /// Returns true when this node's name or one of its\n    /// [groups](#common.NodeProp^group) matches the given string.\n    is(name) {\n        if (typeof name == 'string') {\n            if (this.name == name)\n                return true;\n            let group = this.prop(NodeProp.group);\n            return group ? group.indexOf(name) > -1 : false;\n        }\n        return this.id == name;\n    }\n    /// Create a function from node types to arbitrary values by\n    /// specifying an object whose property names are node or\n    /// [group](#common.NodeProp^group) names. Often useful with\n    /// [`NodeProp.add`](#common.NodeProp.add). You can put multiple\n    /// names, separated by spaces, in a single property name to map\n    /// multiple node names to a single value.\n    static match(map) {\n        let direct = Object.create(null);\n        for (let prop in map)\n            for (let name of prop.split(\" \"))\n                direct[name] = map[prop];\n        return (node) => {\n            for (let groups = node.prop(NodeProp.group), i = -1; i < (groups ? groups.length : 0); i++) {\n                let found = direct[i < 0 ? node.name : groups[i]];\n                if (found)\n                    return found;\n            }\n        };\n    }\n}\n/// An empty dummy node type to use when no actual type is available.\nNodeType.none = new NodeType(\"\", Object.create(null), 0, 8 /* Anonymous */);\n/// A node set holds a collection of node types. It is used to\n/// compactly represent trees by storing their type ids, rather than a\n/// full pointer to the type object, in a numeric array. Each parser\n/// [has](#lr.LRParser.nodeSet) a node set, and [tree\n/// buffers](#common.TreeBuffer) can only store collections of nodes\n/// from the same set. A set can have a maximum of 2**16 (65536) node\n/// types in it, so that the ids fit into 16-bit typed array slots.\nclass NodeSet {\n    /// Create a set with the given types. The `id` property of each\n    /// type should correspond to its position within the array.\n    constructor(\n    /// The node types in this set, by id.\n    types) {\n        this.types = types;\n        for (let i = 0; i < types.length; i++)\n            if (types[i].id != i)\n                throw new RangeError(\"Node type ids should correspond to array positions when creating a node set\");\n    }\n    /// Create a copy of this set with some node properties added. The\n    /// arguments to this method should be created with\n    /// [`NodeProp.add`](#common.NodeProp.add).\n    extend(...props) {\n        let newTypes = [];\n        for (let type of this.types) {\n            let newProps = null;\n            for (let source of props) {\n                let add = source(type);\n                if (add) {\n                    if (!newProps)\n                        newProps = Object.assign({}, type.props);\n                    newProps[add[0].id] = add[1];\n                }\n            }\n            newTypes.push(newProps ? new NodeType(type.name, newProps, type.id, type.flags) : type);\n        }\n        return new NodeSet(newTypes);\n    }\n}\nconst CachedNode = new WeakMap(), CachedInnerNode = new WeakMap();\n/// A piece of syntax tree. There are two ways to approach these\n/// trees: the way they are actually stored in memory, and the\n/// convenient way.\n///\n/// Syntax trees are stored as a tree of `Tree` and `TreeBuffer`\n/// objects. By packing detail information into `TreeBuffer` leaf\n/// nodes, the representation is made a lot more memory-efficient.\n///\n/// However, when you want to actually work with tree nodes, this\n/// representation is very awkward, so most client code will want to\n/// use the [`TreeCursor`](#common.TreeCursor) or\n/// [`SyntaxNode`](#common.SyntaxNode) interface instead, which provides\n/// a view on some part of this data structure, and can be used to\n/// move around to adjacent nodes.\nclass Tree {\n    /// Construct a new tree. See also [`Tree.build`](#common.Tree^build).\n    constructor(\n    /// The type of the top node.\n    type, \n    /// This node's child nodes.\n    children, \n    /// The positions (offsets relative to the start of this tree) of\n    /// the children.\n    positions, \n    /// The total length of this tree\n    length, \n    /// Per-node [node props](#common.NodeProp) to associate with this node.\n    props) {\n        this.type = type;\n        this.children = children;\n        this.positions = positions;\n        this.length = length;\n        /// @internal\n        this.props = null;\n        if (props && props.length) {\n            this.props = Object.create(null);\n            for (let [prop, value] of props)\n                this.props[typeof prop == \"number\" ? prop : prop.id] = value;\n        }\n    }\n    /// @internal\n    toString() {\n        let mounted = this.prop(NodeProp.mounted);\n        if (mounted && !mounted.overlay)\n            return mounted.tree.toString();\n        let children = \"\";\n        for (let ch of this.children) {\n            let str = ch.toString();\n            if (str) {\n                if (children)\n                    children += \",\";\n                children += str;\n            }\n        }\n        return !this.type.name ? children :\n            (/\\W/.test(this.type.name) && !this.type.isError ? JSON.stringify(this.type.name) : this.type.name) +\n                (children.length ? \"(\" + children + \")\" : \"\");\n    }\n    /// Get a [tree cursor](#common.TreeCursor) rooted at this tree. When\n    /// `pos` is given, the cursor is [moved](#common.TreeCursor.moveTo)\n    /// to the given position and side.\n    cursor(pos, side = 0) {\n        let scope = (pos != null && CachedNode.get(this)) || this.topNode;\n        let cursor = new TreeCursor(scope);\n        if (pos != null) {\n            cursor.moveTo(pos, side);\n            CachedNode.set(this, cursor._tree);\n        }\n        return cursor;\n    }\n    /// Get a [tree cursor](#common.TreeCursor) that, unlike regular\n    /// cursors, doesn't skip through\n    /// [anonymous](#common.NodeType.isAnonymous) nodes and doesn't\n    /// automatically enter mounted nodes.\n    fullCursor() {\n        return new TreeCursor(this.topNode, 1 /* Full */);\n    }\n    /// Get a [syntax node](#common.SyntaxNode) object for the top of the\n    /// tree.\n    get topNode() {\n        return new TreeNode(this, 0, 0, null);\n    }\n    /// Get the [syntax node](#common.SyntaxNode) at the given position.\n    /// If `side` is -1, this will move into nodes that end at the\n    /// position. If 1, it'll move into nodes that start at the\n    /// position. With 0, it'll only enter nodes that cover the position\n    /// from both sides.\n    resolve(pos, side = 0) {\n        let node = resolveNode(CachedNode.get(this) || this.topNode, pos, side, false);\n        CachedNode.set(this, node);\n        return node;\n    }\n    /// Like [`resolve`](#common.Tree.resolve), but will enter\n    /// [overlaid](#common.MountedTree.overlay) nodes, producing a syntax node\n    /// pointing into the innermost overlaid tree at the given position\n    /// (with parent links going through all parent structure, including\n    /// the host trees).\n    resolveInner(pos, side = 0) {\n        let node = resolveNode(CachedInnerNode.get(this) || this.topNode, pos, side, true);\n        CachedInnerNode.set(this, node);\n        return node;\n    }\n    /// Iterate over the tree and its children, calling `enter` for any\n    /// node that touches the `from`/`to` region (if given) before\n    /// running over such a node's children, and `leave` (if given) when\n    /// leaving the node. When `enter` returns `false`, that node will\n    /// not have its children iterated over (or `leave` called).\n    iterate(spec) {\n        let { enter, leave, from = 0, to = this.length } = spec;\n        for (let c = this.cursor(), get = () => c.node;;) {\n            let mustLeave = false;\n            if (c.from <= to && c.to >= from && (c.type.isAnonymous || enter(c.type, c.from, c.to, get) !== false)) {\n                if (c.firstChild())\n                    continue;\n                if (!c.type.isAnonymous)\n                    mustLeave = true;\n            }\n            for (;;) {\n                if (mustLeave && leave)\n                    leave(c.type, c.from, c.to, get);\n                mustLeave = c.type.isAnonymous;\n                if (c.nextSibling())\n                    break;\n                if (!c.parent())\n                    return;\n                mustLeave = true;\n            }\n        }\n    }\n    /// Get the value of the given [node prop](#common.NodeProp) for this\n    /// node. Works with both per-node and per-type props.\n    prop(prop) {\n        return !prop.perNode ? this.type.prop(prop) : this.props ? this.props[prop.id] : undefined;\n    }\n    /// Returns the node's [per-node props](#common.NodeProp.perNode) in a\n    /// format that can be passed to the [`Tree`](#common.Tree)\n    /// constructor.\n    get propValues() {\n        let result = [];\n        if (this.props)\n            for (let id in this.props)\n                result.push([+id, this.props[id]]);\n        return result;\n    }\n    /// Balance the direct children of this tree, producing a copy of\n    /// which may have children grouped into subtrees with type\n    /// [`NodeType.none`](#common.NodeType^none).\n    balance(config = {}) {\n        return this.children.length <= 8 /* BranchFactor */ ? this :\n            balanceRange(NodeType.none, this.children, this.positions, 0, this.children.length, 0, this.length, (children, positions, length) => new Tree(this.type, children, positions, length, this.propValues), config.makeTree || ((children, positions, length) => new Tree(NodeType.none, children, positions, length)));\n    }\n    /// Build a tree from a postfix-ordered buffer of node information,\n    /// or a cursor over such a buffer.\n    static build(data) { return buildTree(data); }\n}\n/// The empty tree\nTree.empty = new Tree(NodeType.none, [], [], 0);\nclass FlatBufferCursor {\n    constructor(buffer, index) {\n        this.buffer = buffer;\n        this.index = index;\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    get pos() { return this.index; }\n    next() { this.index -= 4; }\n    fork() { return new FlatBufferCursor(this.buffer, this.index); }\n}\n/// Tree buffers contain (type, start, end, endIndex) quads for each\n/// node. In such a buffer, nodes are stored in prefix order (parents\n/// before children, with the endIndex of the parent indicating which\n/// children belong to it)\nclass TreeBuffer {\n    /// Create a tree buffer.\n    constructor(\n    /// The buffer's content.\n    buffer, \n    /// The total length of the group of nodes in the buffer.\n    length, \n    /// The node set used in this buffer.\n    set) {\n        this.buffer = buffer;\n        this.length = length;\n        this.set = set;\n    }\n    /// @internal\n    get type() { return NodeType.none; }\n    /// @internal\n    toString() {\n        let result = [];\n        for (let index = 0; index < this.buffer.length;) {\n            result.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result.join(\",\");\n    }\n    /// @internal\n    childString(index) {\n        let id = this.buffer[index], endIndex = this.buffer[index + 3];\n        let type = this.set.types[id], result = type.name;\n        if (/\\W/.test(result) && !type.isError)\n            result = JSON.stringify(result);\n        index += 4;\n        if (endIndex == index)\n            return result;\n        let children = [];\n        while (index < endIndex) {\n            children.push(this.childString(index));\n            index = this.buffer[index + 3];\n        }\n        return result + \"(\" + children.join(\",\") + \")\";\n    }\n    /// @internal\n    findChild(startIndex, endIndex, dir, pos, side) {\n        let { buffer } = this, pick = -1;\n        for (let i = startIndex; i != endIndex; i = buffer[i + 3]) {\n            if (checkSide(side, pos, buffer[i + 1], buffer[i + 2])) {\n                pick = i;\n                if (dir > 0)\n                    break;\n            }\n        }\n        return pick;\n    }\n    /// @internal\n    slice(startI, endI, from, to) {\n        let b = this.buffer;\n        let copy = new Uint16Array(endI - startI);\n        for (let i = startI, j = 0; i < endI;) {\n            copy[j++] = b[i++];\n            copy[j++] = b[i++] - from;\n            copy[j++] = b[i++] - from;\n            copy[j++] = b[i++] - startI;\n        }\n        return new TreeBuffer(copy, to - from, this.set);\n    }\n}\nfunction checkSide(side, pos, from, to) {\n    switch (side) {\n        case -2 /* Before */: return from < pos;\n        case -1 /* AtOrBefore */: return to >= pos && from < pos;\n        case 0 /* Around */: return from < pos && to > pos;\n        case 1 /* AtOrAfter */: return from <= pos && to > pos;\n        case 2 /* After */: return to > pos;\n        case 4 /* DontCare */: return true;\n    }\n}\nfunction enterUnfinishedNodesBefore(node, pos) {\n    let scan = node.childBefore(pos);\n    while (scan) {\n        let last = scan.lastChild;\n        if (!last || last.to != scan.to)\n            break;\n        if (last.type.isError && last.from == last.to) {\n            node = scan;\n            scan = last.prevSibling;\n        }\n        else {\n            scan = last;\n        }\n    }\n    return node;\n}\nfunction resolveNode(node, pos, side, overlays) {\n    var _a;\n    // Move up to a node that actually holds the position, if possible\n    while (node.from == node.to ||\n        (side < 1 ? node.from >= pos : node.from > pos) ||\n        (side > -1 ? node.to <= pos : node.to < pos)) {\n        let parent = !overlays && node instanceof TreeNode && node.index < 0 ? null : node.parent;\n        if (!parent)\n            return node;\n        node = parent;\n    }\n    // Must go up out of overlays when those do not overlap with pos\n    if (overlays)\n        for (let scan = node, parent = scan.parent; parent; scan = parent, parent = scan.parent) {\n            if (scan instanceof TreeNode && scan.index < 0 && ((_a = parent.enter(pos, side, true)) === null || _a === void 0 ? void 0 : _a.from) != scan.from)\n                node = parent;\n        }\n    for (;;) {\n        let inner = node.enter(pos, side, overlays);\n        if (!inner)\n            return node;\n        node = inner;\n    }\n}\nclass TreeNode {\n    constructor(node, _from, \n    // Index in parent node, set to -1 if the node is not a direct child of _parent.node (overlay)\n    index, _parent) {\n        this.node = node;\n        this._from = _from;\n        this.index = index;\n        this._parent = _parent;\n    }\n    get type() { return this.node.type; }\n    get name() { return this.node.type.name; }\n    get from() { return this._from; }\n    get to() { return this._from + this.node.length; }\n    nextChild(i, dir, pos, side, mode = 0) {\n        for (let parent = this;;) {\n            for (let { children, positions } = parent.node, e = dir > 0 ? children.length : -1; i != e; i += dir) {\n                let next = children[i], start = positions[i] + parent._from;\n                if (!checkSide(side, pos, start, start + next.length))\n                    continue;\n                if (next instanceof TreeBuffer) {\n                    if (mode & 2 /* NoEnterBuffer */)\n                        continue;\n                    let index = next.findChild(0, next.buffer.length, dir, pos - start, side);\n                    if (index > -1)\n                        return new BufferNode(new BufferContext(parent, next, i, start), null, index);\n                }\n                else if ((mode & 1 /* Full */) || (!next.type.isAnonymous || hasChild(next))) {\n                    let mounted;\n                    if (!(mode & 1 /* Full */) && next.props && (mounted = next.prop(NodeProp.mounted)) && !mounted.overlay)\n                        return new TreeNode(mounted.tree, start, i, parent);\n                    let inner = new TreeNode(next, start, i, parent);\n                    return (mode & 1 /* Full */) || !inner.type.isAnonymous ? inner\n                        : inner.nextChild(dir < 0 ? next.children.length - 1 : 0, dir, pos, side);\n                }\n            }\n            if ((mode & 1 /* Full */) || !parent.type.isAnonymous)\n                return null;\n            if (parent.index >= 0)\n                i = parent.index + dir;\n            else\n                i = dir < 0 ? -1 : parent._parent.node.children.length;\n            parent = parent._parent;\n            if (!parent)\n                return null;\n        }\n    }\n    get firstChild() { return this.nextChild(0, 1, 0, 4 /* DontCare */); }\n    get lastChild() { return this.nextChild(this.node.children.length - 1, -1, 0, 4 /* DontCare */); }\n    childAfter(pos) { return this.nextChild(0, 1, pos, 2 /* After */); }\n    childBefore(pos) { return this.nextChild(this.node.children.length - 1, -1, pos, -2 /* Before */); }\n    enter(pos, side, overlays = true, buffers = true) {\n        let mounted;\n        if (overlays && (mounted = this.node.prop(NodeProp.mounted)) && mounted.overlay) {\n            let rPos = pos - this.from;\n            for (let { from, to } of mounted.overlay) {\n                if ((side > 0 ? from <= rPos : from < rPos) &&\n                    (side < 0 ? to >= rPos : to > rPos))\n                    return new TreeNode(mounted.tree, mounted.overlay[0].from + this.from, -1, this);\n            }\n        }\n        return this.nextChild(0, 1, pos, side, buffers ? 0 : 2 /* NoEnterBuffer */);\n    }\n    nextSignificantParent() {\n        let val = this;\n        while (val.type.isAnonymous && val._parent)\n            val = val._parent;\n        return val;\n    }\n    get parent() {\n        return this._parent ? this._parent.nextSignificantParent() : null;\n    }\n    get nextSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index + 1, 1, 0, 4 /* DontCare */) : null;\n    }\n    get prevSibling() {\n        return this._parent && this.index >= 0 ? this._parent.nextChild(this.index - 1, -1, 0, 4 /* DontCare */) : null;\n    }\n    get cursor() { return new TreeCursor(this); }\n    get tree() { return this.node; }\n    toTree() { return this.node; }\n    resolve(pos, side = 0) {\n        return resolveNode(this, pos, side, false);\n    }\n    resolveInner(pos, side = 0) {\n        return resolveNode(this, pos, side, true);\n    }\n    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n    /// @internal\n    toString() { return this.node.toString(); }\n}\nfunction getChildren(node, type, before, after) {\n    let cur = node.cursor, result = [];\n    if (!cur.firstChild())\n        return result;\n    if (before != null)\n        while (!cur.type.is(before))\n            if (!cur.nextSibling())\n                return result;\n    for (;;) {\n        if (after != null && cur.type.is(after))\n            return result;\n        if (cur.type.is(type))\n            result.push(cur.node);\n        if (!cur.nextSibling())\n            return after == null ? result : [];\n    }\n}\nclass BufferContext {\n    constructor(parent, buffer, index, start) {\n        this.parent = parent;\n        this.buffer = buffer;\n        this.index = index;\n        this.start = start;\n    }\n}\nclass BufferNode {\n    constructor(context, _parent, index) {\n        this.context = context;\n        this._parent = _parent;\n        this.index = index;\n        this.type = context.buffer.set.types[context.buffer.buffer[index]];\n    }\n    get name() { return this.type.name; }\n    get from() { return this.context.start + this.context.buffer.buffer[this.index + 1]; }\n    get to() { return this.context.start + this.context.buffer.buffer[this.index + 2]; }\n    child(dir, pos, side) {\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get firstChild() { return this.child(1, 0, 4 /* DontCare */); }\n    get lastChild() { return this.child(-1, 0, 4 /* DontCare */); }\n    childAfter(pos) { return this.child(1, pos, 2 /* After */); }\n    childBefore(pos) { return this.child(-1, pos, -2 /* Before */); }\n    enter(pos, side, overlays, buffers = true) {\n        if (!buffers)\n            return null;\n        let { buffer } = this.context;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], side > 0 ? 1 : -1, pos - this.context.start, side);\n        return index < 0 ? null : new BufferNode(this.context, this, index);\n    }\n    get parent() {\n        return this._parent || this.context.parent.nextSignificantParent();\n    }\n    externalSibling(dir) {\n        return this._parent ? null : this.context.parent.nextChild(this.context.index + dir, dir, 0, 4 /* DontCare */);\n    }\n    get nextSibling() {\n        let { buffer } = this.context;\n        let after = buffer.buffer[this.index + 3];\n        if (after < (this._parent ? buffer.buffer[this._parent.index + 3] : buffer.buffer.length))\n            return new BufferNode(this.context, this._parent, after);\n        return this.externalSibling(1);\n    }\n    get prevSibling() {\n        let { buffer } = this.context;\n        let parentStart = this._parent ? this._parent.index + 4 : 0;\n        if (this.index == parentStart)\n            return this.externalSibling(-1);\n        return new BufferNode(this.context, this._parent, buffer.findChild(parentStart, this.index, -1, 0, 4 /* DontCare */));\n    }\n    get cursor() { return new TreeCursor(this); }\n    get tree() { return null; }\n    toTree() {\n        let children = [], positions = [];\n        let { buffer } = this.context;\n        let startI = this.index + 4, endI = buffer.buffer[this.index + 3];\n        if (endI > startI) {\n            let from = buffer.buffer[this.index + 1], to = buffer.buffer[this.index + 2];\n            children.push(buffer.slice(startI, endI, from, to));\n            positions.push(0);\n        }\n        return new Tree(this.type, children, positions, this.to - this.from);\n    }\n    resolve(pos, side = 0) {\n        return resolveNode(this, pos, side, false);\n    }\n    resolveInner(pos, side = 0) {\n        return resolveNode(this, pos, side, true);\n    }\n    enterUnfinishedNodesBefore(pos) { return enterUnfinishedNodesBefore(this, pos); }\n    /// @internal\n    toString() { return this.context.buffer.childString(this.index); }\n    getChild(type, before = null, after = null) {\n        let r = getChildren(this, type, before, after);\n        return r.length ? r[0] : null;\n    }\n    getChildren(type, before = null, after = null) {\n        return getChildren(this, type, before, after);\n    }\n}\n/// A tree cursor object focuses on a given node in a syntax tree, and\n/// allows you to move to adjacent nodes.\nclass TreeCursor {\n    /// @internal\n    constructor(node, \n    /// @internal\n    mode = 0) {\n        this.mode = mode;\n        this.buffer = null;\n        this.stack = [];\n        this.index = 0;\n        this.bufferNode = null;\n        if (node instanceof TreeNode) {\n            this.yieldNode(node);\n        }\n        else {\n            this._tree = node.context.parent;\n            this.buffer = node.context;\n            for (let n = node._parent; n; n = n._parent)\n                this.stack.unshift(n.index);\n            this.bufferNode = node;\n            this.yieldBuf(node.index);\n        }\n    }\n    /// Shorthand for `.type.name`.\n    get name() { return this.type.name; }\n    yieldNode(node) {\n        if (!node)\n            return false;\n        this._tree = node;\n        this.type = node.type;\n        this.from = node.from;\n        this.to = node.to;\n        return true;\n    }\n    yieldBuf(index, type) {\n        this.index = index;\n        let { start, buffer } = this.buffer;\n        this.type = type || buffer.set.types[buffer.buffer[index]];\n        this.from = start + buffer.buffer[index + 1];\n        this.to = start + buffer.buffer[index + 2];\n        return true;\n    }\n    yield(node) {\n        if (!node)\n            return false;\n        if (node instanceof TreeNode) {\n            this.buffer = null;\n            return this.yieldNode(node);\n        }\n        this.buffer = node.context;\n        return this.yieldBuf(node.index, node.type);\n    }\n    /// @internal\n    toString() {\n        return this.buffer ? this.buffer.buffer.childString(this.index) : this._tree.toString();\n    }\n    /// @internal\n    enterChild(dir, pos, side) {\n        if (!this.buffer)\n            return this.yield(this._tree.nextChild(dir < 0 ? this._tree.node.children.length - 1 : 0, dir, pos, side, this.mode));\n        let { buffer } = this.buffer;\n        let index = buffer.findChild(this.index + 4, buffer.buffer[this.index + 3], dir, pos - this.buffer.start, side);\n        if (index < 0)\n            return false;\n        this.stack.push(this.index);\n        return this.yieldBuf(index);\n    }\n    /// Move the cursor to this node's first child. When this returns\n    /// false, the node has no child, and the cursor has not been moved.\n    firstChild() { return this.enterChild(1, 0, 4 /* DontCare */); }\n    /// Move the cursor to this node's last child.\n    lastChild() { return this.enterChild(-1, 0, 4 /* DontCare */); }\n    /// Move the cursor to the first child that ends after `pos`.\n    childAfter(pos) { return this.enterChild(1, pos, 2 /* After */); }\n    /// Move to the last child that starts before `pos`.\n    childBefore(pos) { return this.enterChild(-1, pos, -2 /* Before */); }\n    /// Move the cursor to the child around `pos`. If side is -1 the\n    /// child may end at that position, when 1 it may start there. This\n    /// will also enter [overlaid](#common.MountedTree.overlay)\n    /// [mounted](#common.NodeProp^mounted) trees unless `overlays` is\n    /// set to false.\n    enter(pos, side, overlays = true, buffers = true) {\n        if (!this.buffer)\n            return this.yield(this._tree.enter(pos, side, overlays && !(this.mode & 1 /* Full */), buffers));\n        return buffers ? this.enterChild(1, pos, side) : false;\n    }\n    /// Move to the node's parent node, if this isn't the top node.\n    parent() {\n        if (!this.buffer)\n            return this.yieldNode((this.mode & 1 /* Full */) ? this._tree._parent : this._tree.parent);\n        if (this.stack.length)\n            return this.yieldBuf(this.stack.pop());\n        let parent = (this.mode & 1 /* Full */) ? this.buffer.parent : this.buffer.parent.nextSignificantParent();\n        this.buffer = null;\n        return this.yieldNode(parent);\n    }\n    /// @internal\n    sibling(dir) {\n        if (!this.buffer)\n            return !this._tree._parent ? false\n                : this.yield(this._tree.index < 0 ? null\n                    : this._tree._parent.nextChild(this._tree.index + dir, dir, 0, 4 /* DontCare */, this.mode));\n        let { buffer } = this.buffer, d = this.stack.length - 1;\n        if (dir < 0) {\n            let parentStart = d < 0 ? 0 : this.stack[d] + 4;\n            if (this.index != parentStart)\n                return this.yieldBuf(buffer.findChild(parentStart, this.index, -1, 0, 4 /* DontCare */));\n        }\n        else {\n            let after = buffer.buffer[this.index + 3];\n            if (after < (d < 0 ? buffer.buffer.length : buffer.buffer[this.stack[d] + 3]))\n                return this.yieldBuf(after);\n        }\n        return d < 0 ? this.yield(this.buffer.parent.nextChild(this.buffer.index + dir, dir, 0, 4 /* DontCare */, this.mode)) : false;\n    }\n    /// Move to this node's next sibling, if any.\n    nextSibling() { return this.sibling(1); }\n    /// Move to this node's previous sibling, if any.\n    prevSibling() { return this.sibling(-1); }\n    atLastNode(dir) {\n        let index, parent, { buffer } = this;\n        if (buffer) {\n            if (dir > 0) {\n                if (this.index < buffer.buffer.buffer.length)\n                    return false;\n            }\n            else {\n                for (let i = 0; i < this.index; i++)\n                    if (buffer.buffer.buffer[i + 3] < this.index)\n                        return false;\n            }\n            ({ index, parent } = buffer);\n        }\n        else {\n            ({ index, _parent: parent } = this._tree);\n        }\n        for (; parent; { index, _parent: parent } = parent) {\n            if (index > -1)\n                for (let i = index + dir, e = dir < 0 ? -1 : parent.node.children.length; i != e; i += dir) {\n                    let child = parent.node.children[i];\n                    if ((this.mode & 1 /* Full */) || child instanceof TreeBuffer || !child.type.isAnonymous || hasChild(child))\n                        return false;\n                }\n        }\n        return true;\n    }\n    move(dir, enter) {\n        if (enter && this.enterChild(dir, 0, 4 /* DontCare */))\n            return true;\n        for (;;) {\n            if (this.sibling(dir))\n                return true;\n            if (this.atLastNode(dir) || !this.parent())\n                return false;\n        }\n    }\n    /// Move to the next node in a\n    /// [pre-order](https://en.wikipedia.org/wiki/Tree_traversal#Pre-order_(NLR))\n    /// traversal, going from a node to its first child or, if the\n    /// current node is empty or `enter` is false, its next sibling or\n    /// the next sibling of the first parent node that has one.\n    next(enter = true) { return this.move(1, enter); }\n    /// Move to the next node in a last-to-first pre-order traveral. A\n    /// node is followed by its last child or, if it has none, its\n    /// previous sibling or the previous sibling of the first parent\n    /// node that has one.\n    prev(enter = true) { return this.move(-1, enter); }\n    /// Move the cursor to the innermost node that covers `pos`. If\n    /// `side` is -1, it will enter nodes that end at `pos`. If it is 1,\n    /// it will enter nodes that start at `pos`.\n    moveTo(pos, side = 0) {\n        // Move up to a node that actually holds the position, if possible\n        while (this.from == this.to ||\n            (side < 1 ? this.from >= pos : this.from > pos) ||\n            (side > -1 ? this.to <= pos : this.to < pos))\n            if (!this.parent())\n                break;\n        // Then scan down into child nodes as far as possible\n        while (this.enterChild(1, pos, side)) { }\n        return this;\n    }\n    /// Get a [syntax node](#common.SyntaxNode) at the cursor's current\n    /// position.\n    get node() {\n        if (!this.buffer)\n            return this._tree;\n        let cache = this.bufferNode, result = null, depth = 0;\n        if (cache && cache.context == this.buffer) {\n            scan: for (let index = this.index, d = this.stack.length; d >= 0;) {\n                for (let c = cache; c; c = c._parent)\n                    if (c.index == index) {\n                        if (index == this.index)\n                            return c;\n                        result = c;\n                        depth = d + 1;\n                        break scan;\n                    }\n                index = this.stack[--d];\n            }\n        }\n        for (let i = depth; i < this.stack.length; i++)\n            result = new BufferNode(this.buffer, result, this.stack[i]);\n        return this.bufferNode = new BufferNode(this.buffer, result, this.index);\n    }\n    /// Get the [tree](#common.Tree) that represents the current node, if\n    /// any. Will return null when the node is in a [tree\n    /// buffer](#common.TreeBuffer).\n    get tree() {\n        return this.buffer ? null : this._tree.node;\n    }\n}\nfunction hasChild(tree) {\n    return tree.children.some(ch => ch instanceof TreeBuffer || !ch.type.isAnonymous || hasChild(ch));\n}\nfunction buildTree(data) {\n    var _a;\n    let { buffer, nodeSet, maxBufferLength = DefaultBufferLength, reused = [], minRepeatType = nodeSet.types.length } = data;\n    let cursor = Array.isArray(buffer) ? new FlatBufferCursor(buffer, buffer.length) : buffer;\n    let types = nodeSet.types;\n    let contextHash = 0, lookAhead = 0;\n    function takeNode(parentStart, minPos, children, positions, inRepeat) {\n        let { id, start, end, size } = cursor;\n        let lookAheadAtStart = lookAhead;\n        while (size < 0) {\n            cursor.next();\n            if (size == -1 /* Reuse */) {\n                let node = reused[id];\n                children.push(node);\n                positions.push(start - parentStart);\n                return;\n            }\n            else if (size == -3 /* ContextChange */) { // Context change\n                contextHash = id;\n                return;\n            }\n            else if (size == -4 /* LookAhead */) {\n                lookAhead = id;\n                return;\n            }\n            else {\n                throw new RangeError(`Unrecognized record size: ${size}`);\n            }\n        }\n        let type = types[id], node, buffer;\n        let startPos = start - parentStart;\n        if (end - start <= maxBufferLength && (buffer = findBufferSize(cursor.pos - minPos, inRepeat))) {\n            // Small enough for a buffer, and no reused nodes inside\n            let data = new Uint16Array(buffer.size - buffer.skip);\n            let endPos = cursor.pos - buffer.size, index = data.length;\n            while (cursor.pos > endPos)\n                index = copyToBuffer(buffer.start, data, index);\n            node = new TreeBuffer(data, end - buffer.start, nodeSet);\n            startPos = buffer.start - parentStart;\n        }\n        else { // Make it a node\n            let endPos = cursor.pos - size;\n            cursor.next();\n            let localChildren = [], localPositions = [];\n            let localInRepeat = id >= minRepeatType ? id : -1;\n            let lastGroup = 0, lastEnd = end;\n            while (cursor.pos > endPos) {\n                if (localInRepeat >= 0 && cursor.id == localInRepeat && cursor.size >= 0) {\n                    if (cursor.end <= lastEnd - maxBufferLength) {\n                        makeRepeatLeaf(localChildren, localPositions, start, lastGroup, cursor.end, lastEnd, localInRepeat, lookAheadAtStart);\n                        lastGroup = localChildren.length;\n                        lastEnd = cursor.end;\n                    }\n                    cursor.next();\n                }\n                else {\n                    takeNode(start, endPos, localChildren, localPositions, localInRepeat);\n                }\n            }\n            if (localInRepeat >= 0 && lastGroup > 0 && lastGroup < localChildren.length)\n                makeRepeatLeaf(localChildren, localPositions, start, lastGroup, start, lastEnd, localInRepeat, lookAheadAtStart);\n            localChildren.reverse();\n            localPositions.reverse();\n            if (localInRepeat > -1 && lastGroup > 0) {\n                let make = makeBalanced(type);\n                node = balanceRange(type, localChildren, localPositions, 0, localChildren.length, 0, end - start, make, make);\n            }\n            else {\n                node = makeTree(type, localChildren, localPositions, end - start, lookAheadAtStart - end);\n            }\n        }\n        children.push(node);\n        positions.push(startPos);\n    }\n    function makeBalanced(type) {\n        return (children, positions, length) => {\n            let lookAhead = 0, lastI = children.length - 1, last, lookAheadProp;\n            if (lastI >= 0 && (last = children[lastI]) instanceof Tree) {\n                if (!lastI && last.type == type && last.length == length)\n                    return last;\n                if (lookAheadProp = last.prop(NodeProp.lookAhead))\n                    lookAhead = positions[lastI] + last.length + lookAheadProp;\n            }\n            return makeTree(type, children, positions, length, lookAhead);\n        };\n    }\n    function makeRepeatLeaf(children, positions, base, i, from, to, type, lookAhead) {\n        let localChildren = [], localPositions = [];\n        while (children.length > i) {\n            localChildren.push(children.pop());\n            localPositions.push(positions.pop() + base - from);\n        }\n        children.push(makeTree(nodeSet.types[type], localChildren, localPositions, to - from, lookAhead - to));\n        positions.push(from - base);\n    }\n    function makeTree(type, children, positions, length, lookAhead = 0, props) {\n        if (contextHash) {\n            let pair = [NodeProp.contextHash, contextHash];\n            props = props ? [pair].concat(props) : [pair];\n        }\n        if (lookAhead > 25) {\n            let pair = [NodeProp.lookAhead, lookAhead];\n            props = props ? [pair].concat(props) : [pair];\n        }\n        return new Tree(type, children, positions, length, props);\n    }\n    function findBufferSize(maxSize, inRepeat) {\n        // Scan through the buffer to find previous siblings that fit\n        // together in a TreeBuffer, and don't contain any reused nodes\n        // (which can't be stored in a buffer).\n        // If `inRepeat` is > -1, ignore node boundaries of that type for\n        // nesting, but make sure the end falls either at the start\n        // (`maxSize`) or before such a node.\n        let fork = cursor.fork();\n        let size = 0, start = 0, skip = 0, minStart = fork.end - maxBufferLength;\n        let result = { size: 0, start: 0, skip: 0 };\n        scan: for (let minPos = fork.pos - maxSize; fork.pos > minPos;) {\n            let nodeSize = fork.size;\n            // Pretend nested repeat nodes of the same type don't exist\n            if (fork.id == inRepeat && nodeSize >= 0) {\n                // Except that we store the current state as a valid return\n                // value.\n                result.size = size;\n                result.start = start;\n                result.skip = skip;\n                skip += 4;\n                size += 4;\n                fork.next();\n                continue;\n            }\n            let startPos = fork.pos - nodeSize;\n            if (nodeSize < 0 || startPos < minPos || fork.start < minStart)\n                break;\n            let localSkipped = fork.id >= minRepeatType ? 4 : 0;\n            let nodeStart = fork.start;\n            fork.next();\n            while (fork.pos > startPos) {\n                if (fork.size < 0) {\n                    if (fork.size == -3 /* ContextChange */)\n                        localSkipped += 4;\n                    else\n                        break scan;\n                }\n                else if (fork.id >= minRepeatType) {\n                    localSkipped += 4;\n                }\n                fork.next();\n            }\n            start = nodeStart;\n            size += nodeSize;\n            skip += localSkipped;\n        }\n        if (inRepeat < 0 || size == maxSize) {\n            result.size = size;\n            result.start = start;\n            result.skip = skip;\n        }\n        return result.size > 4 ? result : undefined;\n    }\n    function copyToBuffer(bufferStart, buffer, index) {\n        let { id, start, end, size } = cursor;\n        cursor.next();\n        if (size >= 0 && id < minRepeatType) {\n            let startIndex = index;\n            if (size > 4) {\n                let endPos = cursor.pos - (size - 4);\n                while (cursor.pos > endPos)\n                    index = copyToBuffer(bufferStart, buffer, index);\n            }\n            buffer[--index] = startIndex;\n            buffer[--index] = end - bufferStart;\n            buffer[--index] = start - bufferStart;\n            buffer[--index] = id;\n        }\n        else if (size == -3 /* ContextChange */) {\n            contextHash = id;\n        }\n        else if (size == -4 /* LookAhead */) {\n            lookAhead = id;\n        }\n        return index;\n    }\n    let children = [], positions = [];\n    while (cursor.pos > 0)\n        takeNode(data.start || 0, data.bufferStart || 0, children, positions, -1);\n    let length = (_a = data.length) !== null && _a !== void 0 ? _a : (children.length ? positions[0] + children[0].length : 0);\n    return new Tree(types[data.topID], children.reverse(), positions.reverse(), length);\n}\nconst nodeSizeCache = new WeakMap;\nfunction nodeSize(balanceType, node) {\n    if (!balanceType.isAnonymous || node instanceof TreeBuffer || node.type != balanceType)\n        return 1;\n    let size = nodeSizeCache.get(node);\n    if (size == null) {\n        size = 1;\n        for (let child of node.children) {\n            if (child.type != balanceType || !(child instanceof Tree)) {\n                size = 1;\n                break;\n            }\n            size += nodeSize(balanceType, child);\n        }\n        nodeSizeCache.set(node, size);\n    }\n    return size;\n}\nfunction balanceRange(\n// The type the balanced tree's inner nodes.\nbalanceType, \n// The direct children and their positions\nchildren, positions, \n// The index range in children/positions to use\nfrom, to, \n// The start position of the nodes, relative to their parent.\nstart, \n// Length of the outer node\nlength, \n// Function to build the top node of the balanced tree\nmkTop, \n// Function to build internal nodes for the balanced tree\nmkTree) {\n    let total = 0;\n    for (let i = from; i < to; i++)\n        total += nodeSize(balanceType, children[i]);\n    let maxChild = Math.ceil((total * 1.5) / 8 /* BranchFactor */);\n    let localChildren = [], localPositions = [];\n    function divide(children, positions, from, to, offset) {\n        for (let i = from; i < to;) {\n            let groupFrom = i, groupStart = positions[i], groupSize = nodeSize(balanceType, children[i]);\n            i++;\n            for (; i < to; i++) {\n                let nextSize = nodeSize(balanceType, children[i]);\n                if (groupSize + nextSize >= maxChild)\n                    break;\n                groupSize += nextSize;\n            }\n            if (i == groupFrom + 1) {\n                if (groupSize > maxChild) {\n                    let only = children[groupFrom]; // Only trees can have a size > 1\n                    divide(only.children, only.positions, 0, only.children.length, positions[groupFrom] + offset);\n                    continue;\n                }\n                localChildren.push(children[groupFrom]);\n            }\n            else {\n                let length = positions[i - 1] + children[i - 1].length - groupStart;\n                localChildren.push(balanceRange(balanceType, children, positions, groupFrom, i, groupStart, length, null, mkTree));\n            }\n            localPositions.push(groupStart + offset - start);\n        }\n    }\n    divide(children, positions, from, to, 0);\n    return (mkTop || mkTree)(localChildren, localPositions, length);\n}\n\n/// Tree fragments are used during [incremental\n/// parsing](#common.Parser.startParse) to track parts of old trees\n/// that can be reused in a new parse. An array of fragments is used\n/// to track regions of an old tree whose nodes might be reused in new\n/// parses. Use the static\n/// [`applyChanges`](#common.TreeFragment^applyChanges) method to\n/// update fragments for document changes.\nclass TreeFragment {\n    /// Construct a tree fragment.\n    constructor(\n    /// The start of the unchanged range pointed to by this fragment.\n    /// This refers to an offset in the _updated_ document (as opposed\n    /// to the original tree).\n    from, \n    /// The end of the unchanged range.\n    to, \n    /// The tree that this fragment is based on.\n    tree, \n    /// The offset between the fragment's tree and the document that\n    /// this fragment can be used against. Add this when going from\n    /// document to tree positions, subtract it to go from tree to\n    /// document positions.\n    offset, openStart = false, openEnd = false) {\n        this.from = from;\n        this.to = to;\n        this.tree = tree;\n        this.offset = offset;\n        this.open = (openStart ? 1 /* Start */ : 0) | (openEnd ? 2 /* End */ : 0);\n    }\n    /// Whether the start of the fragment represents the start of a\n    /// parse, or the end of a change. (In the second case, it may not\n    /// be safe to reuse some nodes at the start, depending on the\n    /// parsing algorithm.)\n    get openStart() { return (this.open & 1 /* Start */) > 0; }\n    /// Whether the end of the fragment represents the end of a\n    /// full-document parse, or the start of a change.\n    get openEnd() { return (this.open & 2 /* End */) > 0; }\n    /// Create a set of fragments from a freshly parsed tree, or update\n    /// an existing set of fragments by replacing the ones that overlap\n    /// with a tree with content from the new tree. When `partial` is\n    /// true, the parse is treated as incomplete, and the resulting\n    /// fragment has [`openEnd`](#common.TreeFragment.openEnd) set to\n    /// true.\n    static addTree(tree, fragments = [], partial = false) {\n        let result = [new TreeFragment(0, tree.length, tree, 0, false, partial)];\n        for (let f of fragments)\n            if (f.to > tree.length)\n                result.push(f);\n        return result;\n    }\n    /// Apply a set of edits to an array of fragments, removing or\n    /// splitting fragments as necessary to remove edited ranges, and\n    /// adjusting offsets for fragments that moved.\n    static applyChanges(fragments, changes, minGap = 128) {\n        if (!changes.length)\n            return fragments;\n        let result = [];\n        let fI = 1, nextF = fragments.length ? fragments[0] : null;\n        for (let cI = 0, pos = 0, off = 0;; cI++) {\n            let nextC = cI < changes.length ? changes[cI] : null;\n            let nextPos = nextC ? nextC.fromA : 1e9;\n            if (nextPos - pos >= minGap)\n                while (nextF && nextF.from < nextPos) {\n                    let cut = nextF;\n                    if (pos >= cut.from || nextPos <= cut.to || off) {\n                        let fFrom = Math.max(cut.from, pos) - off, fTo = Math.min(cut.to, nextPos) - off;\n                        cut = fFrom >= fTo ? null : new TreeFragment(fFrom, fTo, cut.tree, cut.offset + off, cI > 0, !!nextC);\n                    }\n                    if (cut)\n                        result.push(cut);\n                    if (nextF.to > nextPos)\n                        break;\n                    nextF = fI < fragments.length ? fragments[fI++] : null;\n                }\n            if (!nextC)\n                break;\n            pos = nextC.toA;\n            off = nextC.toA - nextC.toB;\n        }\n        return result;\n    }\n}\n/// A superclass that parsers should extend.\nclass Parser {\n    /// Start a parse, returning a [partial parse](#common.PartialParse)\n    /// object. [`fragments`](#common.TreeFragment) can be passed in to\n    /// make the parse incremental.\n    ///\n    /// By default, the entire input is parsed. You can pass `ranges`,\n    /// which should be a sorted array of non-empty, non-overlapping\n    /// ranges, to parse only those ranges. The tree returned in that\n    /// case will start at `ranges[0].from`.\n    startParse(input, fragments, ranges) {\n        if (typeof input == \"string\")\n            input = new StringInput(input);\n        ranges = !ranges ? [new Range(0, input.length)] : ranges.length ? ranges.map(r => new Range(r.from, r.to)) : [new Range(0, 0)];\n        return this.createParse(input, fragments || [], ranges);\n    }\n    /// Run a full parse, returning the resulting tree.\n    parse(input, fragments, ranges) {\n        let parse = this.startParse(input, fragments, ranges);\n        for (;;) {\n            let done = parse.advance();\n            if (done)\n                return done;\n        }\n    }\n}\nclass StringInput {\n    constructor(string) {\n        this.string = string;\n    }\n    get length() { return this.string.length; }\n    chunk(from) { return this.string.slice(from); }\n    get lineChunks() { return false; }\n    read(from, to) { return this.string.slice(from, to); }\n}\n\n/// Create a parse wrapper that, after the inner parse completes,\n/// scans its tree for mixed language regions with the `nest`\n/// function, runs the resulting [inner parses](#common.NestedParse),\n/// and then [mounts](#common.NodeProp^mounted) their results onto the\n/// tree.\n///\n/// The nesting function is passed a cursor to provide context for a\n/// node, but _should not_ move that cursor, only inspect its\n/// properties and optionally access its\n/// [node object](#common.TreeCursor.node).\nfunction parseMixed(nest) {\n    return (parse, input, fragments, ranges) => new MixedParse(parse, nest, input, fragments, ranges);\n}\nclass InnerParse {\n    constructor(parser, parse, overlay, target, ranges) {\n        this.parser = parser;\n        this.parse = parse;\n        this.overlay = overlay;\n        this.target = target;\n        this.ranges = ranges;\n    }\n}\nclass ActiveOverlay {\n    constructor(parser, predicate, mounts, index, start, target, prev) {\n        this.parser = parser;\n        this.predicate = predicate;\n        this.mounts = mounts;\n        this.index = index;\n        this.start = start;\n        this.target = target;\n        this.prev = prev;\n        this.depth = 0;\n        this.ranges = [];\n    }\n}\nconst stoppedInner = new NodeProp({ perNode: true });\nclass MixedParse {\n    constructor(base, nest, input, fragments, ranges) {\n        this.nest = nest;\n        this.input = input;\n        this.fragments = fragments;\n        this.ranges = ranges;\n        this.inner = [];\n        this.innerDone = 0;\n        this.baseTree = null;\n        this.stoppedAt = null;\n        this.baseParse = base;\n    }\n    advance() {\n        if (this.baseParse) {\n            let done = this.baseParse.advance();\n            if (!done)\n                return null;\n            this.baseParse = null;\n            this.baseTree = done;\n            this.startInner();\n            if (this.stoppedAt != null)\n                for (let inner of this.inner)\n                    inner.parse.stopAt(this.stoppedAt);\n        }\n        if (this.innerDone == this.inner.length) {\n            let result = this.baseTree;\n            if (this.stoppedAt != null)\n                result = new Tree(result.type, result.children, result.positions, result.length, result.propValues.concat([[stoppedInner, this.stoppedAt]]));\n            return result;\n        }\n        let inner = this.inner[this.innerDone], done = inner.parse.advance();\n        if (done) {\n            this.innerDone++;\n            // This is a somewhat dodgy but super helpful hack where we\n            // patch up nodes created by the inner parse (and thus\n            // presumably not aliased anywhere else) to hold the information\n            // about the inner parse.\n            let props = Object.assign(Object.create(null), inner.target.props);\n            props[NodeProp.mounted.id] = new MountedTree(done, inner.overlay, inner.parser);\n            inner.target.props = props;\n        }\n        return null;\n    }\n    get parsedPos() {\n        if (this.baseParse)\n            return 0;\n        let pos = this.input.length;\n        for (let i = this.innerDone; i < this.inner.length; i++) {\n            if (this.inner[i].ranges[0].from < pos)\n                pos = Math.min(pos, this.inner[i].parse.parsedPos);\n        }\n        return pos;\n    }\n    stopAt(pos) {\n        this.stoppedAt = pos;\n        if (this.baseParse)\n            this.baseParse.stopAt(pos);\n        else\n            for (let i = this.innerDone; i < this.inner.length; i++)\n                this.inner[i].parse.stopAt(pos);\n    }\n    startInner() {\n        let fragmentCursor = new FragmentCursor(this.fragments);\n        let overlay = null;\n        let covered = null;\n        let cursor = new TreeCursor(new TreeNode(this.baseTree, this.ranges[0].from, 0, null), 1 /* Full */);\n        scan: for (let nest, isCovered; this.stoppedAt == null || cursor.from < this.stoppedAt;) {\n            let enter = true, range;\n            if (fragmentCursor.hasNode(cursor)) {\n                if (overlay) {\n                    let match = overlay.mounts.find(m => m.frag.from <= cursor.from && m.frag.to >= cursor.to && m.mount.overlay);\n                    if (match)\n                        for (let r of match.mount.overlay) {\n                            let from = r.from + match.pos, to = r.to + match.pos;\n                            if (from >= cursor.from && to <= cursor.to)\n                                overlay.ranges.push({ from, to });\n                        }\n                }\n                enter = false;\n            }\n            else if (covered && (isCovered = checkCover(covered.ranges, cursor.from, cursor.to))) {\n                enter = isCovered != 2 /* Full */;\n            }\n            else if (!cursor.type.isAnonymous && cursor.from < cursor.to && (nest = this.nest(cursor, this.input))) {\n                if (!cursor.tree)\n                    materialize(cursor);\n                let oldMounts = fragmentCursor.findMounts(cursor.from, nest.parser);\n                if (typeof nest.overlay == \"function\") {\n                    overlay = new ActiveOverlay(nest.parser, nest.overlay, oldMounts, this.inner.length, cursor.from, cursor.tree, overlay);\n                }\n                else {\n                    let ranges = punchRanges(this.ranges, nest.overlay || [new Range(cursor.from, cursor.to)]);\n                    if (ranges.length)\n                        this.inner.push(new InnerParse(nest.parser, nest.parser.startParse(this.input, enterFragments(oldMounts, ranges), ranges), nest.overlay ? nest.overlay.map(r => new Range(r.from - cursor.from, r.to - cursor.from)) : null, cursor.tree, ranges));\n                    if (!nest.overlay)\n                        enter = false;\n                    else if (ranges.length)\n                        covered = { ranges, depth: 0, prev: covered };\n                }\n            }\n            else if (overlay && (range = overlay.predicate(cursor))) {\n                if (range === true)\n                    range = new Range(cursor.from, cursor.to);\n                if (range.from < range.to)\n                    overlay.ranges.push(range);\n            }\n            if (enter && cursor.firstChild()) {\n                if (overlay)\n                    overlay.depth++;\n                if (covered)\n                    covered.depth++;\n            }\n            else {\n                for (;;) {\n                    if (cursor.nextSibling())\n                        break;\n                    if (!cursor.parent())\n                        break scan;\n                    if (overlay && !--overlay.depth) {\n                        let ranges = punchRanges(this.ranges, overlay.ranges);\n                        if (ranges.length)\n                            this.inner.splice(overlay.index, 0, new InnerParse(overlay.parser, overlay.parser.startParse(this.input, enterFragments(overlay.mounts, ranges), ranges), overlay.ranges.map(r => new Range(r.from - overlay.start, r.to - overlay.start)), overlay.target, ranges));\n                        overlay = overlay.prev;\n                    }\n                    if (covered && !--covered.depth)\n                        covered = covered.prev;\n                }\n            }\n        }\n    }\n}\nfunction checkCover(covered, from, to) {\n    for (let range of covered) {\n        if (range.from >= to)\n            break;\n        if (range.to > from)\n            return range.from <= from && range.to >= to ? 2 /* Full */ : 1 /* Partial */;\n    }\n    return 0 /* None */;\n}\n// Take a piece of buffer and convert it into a stand-alone\n// TreeBuffer.\nfunction sliceBuf(buf, startI, endI, nodes, positions, off) {\n    if (startI < endI) {\n        let from = buf.buffer[startI + 1], to = buf.buffer[endI - 2];\n        nodes.push(buf.slice(startI, endI, from, to));\n        positions.push(from - off);\n    }\n}\n// This function takes a node that's in a buffer, and converts it, and\n// its parent buffer nodes, into a Tree. This is again acting on the\n// assumption that the trees and buffers have been constructed by the\n// parse that was ran via the mix parser, and thus aren't shared with\n// any other code, making violations of the immutability safe.\nfunction materialize(cursor) {\n    let { node } = cursor, depth = 0;\n    // Scan up to the nearest tree\n    do {\n        cursor.parent();\n        depth++;\n    } while (!cursor.tree);\n    // Find the index of the buffer in that tree\n    let i = 0, base = cursor.tree, off = 0;\n    for (;; i++) {\n        off = base.positions[i] + cursor.from;\n        if (off <= node.from && off + base.children[i].length >= node.to)\n            break;\n    }\n    let buf = base.children[i], b = buf.buffer;\n    // Split a level in the buffer, putting the nodes before and after\n    // the child that contains `node` into new buffers.\n    function split(startI, endI, type, innerOffset, length) {\n        let i = startI;\n        while (b[i + 2] + off <= node.from)\n            i = b[i + 3];\n        let children = [], positions = [];\n        sliceBuf(buf, startI, i, children, positions, innerOffset);\n        let from = b[i + 1], to = b[i + 2];\n        let isTarget = from + off == node.from && to + off == node.to && b[i] == node.type.id;\n        children.push(isTarget ? node.toTree() : split(i + 4, b[i + 3], buf.set.types[b[i]], from, to - from));\n        positions.push(from - innerOffset);\n        sliceBuf(buf, b[i + 3], endI, children, positions, innerOffset);\n        return new Tree(type, children, positions, length);\n    }\n    base.children[i] = split(0, b.length, NodeType.none, 0, buf.length);\n    // Move the cursor back to the target node\n    for (let d = 0; d <= depth; d++)\n        cursor.childAfter(node.from);\n}\nclass StructureCursor {\n    constructor(root, offset) {\n        this.offset = offset;\n        this.done = false;\n        this.cursor = root.fullCursor();\n    }\n    // Move to the first node (in pre-order) that starts at or after `pos`.\n    moveTo(pos) {\n        let { cursor } = this, p = pos - this.offset;\n        while (!this.done && cursor.from < p) {\n            if (cursor.to >= pos && cursor.enter(p, 1, false, false)) ;\n            else if (!cursor.next(false))\n                this.done = true;\n        }\n    }\n    hasNode(cursor) {\n        this.moveTo(cursor.from);\n        if (!this.done && this.cursor.from + this.offset == cursor.from && this.cursor.tree) {\n            for (let tree = this.cursor.tree;;) {\n                if (tree == cursor.tree)\n                    return true;\n                if (tree.children.length && tree.positions[0] == 0 && tree.children[0] instanceof Tree)\n                    tree = tree.children[0];\n                else\n                    break;\n            }\n        }\n        return false;\n    }\n}\nclass FragmentCursor {\n    constructor(fragments) {\n        var _a;\n        this.fragments = fragments;\n        this.curTo = 0;\n        this.fragI = 0;\n        if (fragments.length) {\n            let first = this.curFrag = fragments[0];\n            this.curTo = (_a = first.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : first.to;\n            this.inner = new StructureCursor(first.tree, -first.offset);\n        }\n        else {\n            this.curFrag = this.inner = null;\n        }\n    }\n    hasNode(node) {\n        while (this.curFrag && node.from >= this.curTo)\n            this.nextFrag();\n        return this.curFrag && this.curFrag.from <= node.from && this.curTo >= node.to && this.inner.hasNode(node);\n    }\n    nextFrag() {\n        var _a;\n        this.fragI++;\n        if (this.fragI == this.fragments.length) {\n            this.curFrag = this.inner = null;\n        }\n        else {\n            let frag = this.curFrag = this.fragments[this.fragI];\n            this.curTo = (_a = frag.tree.prop(stoppedInner)) !== null && _a !== void 0 ? _a : frag.to;\n            this.inner = new StructureCursor(frag.tree, -frag.offset);\n        }\n    }\n    findMounts(pos, parser) {\n        var _a;\n        let result = [];\n        if (this.inner) {\n            this.inner.cursor.moveTo(pos, 1);\n            for (let pos = this.inner.cursor.node; pos; pos = pos.parent) {\n                let mount = (_a = pos.tree) === null || _a === void 0 ? void 0 : _a.prop(NodeProp.mounted);\n                if (mount && mount.parser == parser) {\n                    for (let i = this.fragI; i < this.fragments.length; i++) {\n                        let frag = this.fragments[i];\n                        if (frag.from >= pos.to)\n                            break;\n                        if (frag.tree == this.curFrag.tree)\n                            result.push({\n                                frag,\n                                pos: pos.from - frag.offset,\n                                mount\n                            });\n                    }\n                }\n            }\n        }\n        return result;\n    }\n}\nfunction punchRanges(outer, ranges) {\n    let copy = null, current = ranges;\n    for (let i = 1, j = 0; i < outer.length; i++) {\n        let gapFrom = outer[i - 1].to, gapTo = outer[i].from;\n        for (; j < current.length; j++) {\n            let r = current[j];\n            if (r.from >= gapTo)\n                break;\n            if (r.to <= gapFrom)\n                continue;\n            if (!copy)\n                current = copy = ranges.slice();\n            if (r.from < gapFrom) {\n                copy[j] = new Range(r.from, gapFrom);\n                if (r.to > gapTo)\n                    copy.splice(j + 1, 0, new Range(gapTo, r.to));\n            }\n            else if (r.to > gapTo) {\n                copy[j--] = new Range(gapTo, r.to);\n            }\n            else {\n                copy.splice(j--, 1);\n            }\n        }\n    }\n    return current;\n}\nfunction findCoverChanges(a, b, from, to) {\n    let iA = 0, iB = 0, inA = false, inB = false, pos = -1e9;\n    let result = [];\n    for (;;) {\n        let nextA = iA == a.length ? 1e9 : inA ? a[iA].to : a[iA].from;\n        let nextB = iB == b.length ? 1e9 : inB ? b[iB].to : b[iB].from;\n        if (inA != inB) {\n            let start = Math.max(pos, from), end = Math.min(nextA, nextB, to);\n            if (start < end)\n                result.push(new Range(start, end));\n        }\n        pos = Math.min(nextA, nextB);\n        if (pos == 1e9)\n            break;\n        if (nextA == pos) {\n            if (!inA)\n                inA = true;\n            else {\n                inA = false;\n                iA++;\n            }\n        }\n        if (nextB == pos) {\n            if (!inB)\n                inB = true;\n            else {\n                inB = false;\n                iB++;\n            }\n        }\n    }\n    return result;\n}\n// Given a number of fragments for the outer tree, and a set of ranges\n// to parse, find fragments for inner trees mounted around those\n// ranges, if any.\nfunction enterFragments(mounts, ranges) {\n    let result = [];\n    for (let { pos, mount, frag } of mounts) {\n        let startPos = pos + (mount.overlay ? mount.overlay[0].from : 0), endPos = startPos + mount.tree.length;\n        let from = Math.max(frag.from, startPos), to = Math.min(frag.to, endPos);\n        if (mount.overlay) {\n            let overlay = mount.overlay.map(r => new Range(r.from + pos, r.to + pos));\n            let changes = findCoverChanges(ranges, overlay, from, to);\n            for (let i = 0, pos = from;; i++) {\n                let last = i == changes.length, end = last ? to : changes[i].from;\n                if (end > pos)\n                    result.push(new TreeFragment(pos, end, mount.tree, -startPos, frag.from >= pos, frag.to <= end));\n                if (last)\n                    break;\n                pos = changes[i].to;\n            }\n        }\n        else {\n            result.push(new TreeFragment(from, to, mount.tree, -startPos, frag.from >= startPos, frag.to <= endPos));\n        }\n    }\n    return result;\n}\n\nexport { DefaultBufferLength, MountedTree, NodeProp, NodeSet, NodeType, Parser, Tree, TreeBuffer, TreeCursor, TreeFragment, parseMixed };\n","import { Parser, NodeSet, NodeType, DefaultBufferLength, NodeProp, Tree } from '@lezer/common';\n\n/// A parse stack. These are used internally by the parser to track\n/// parsing progress. They also provide some properties and methods\n/// that external code such as a tokenizer can use to get information\n/// about the parse state.\nclass Stack {\n    /// @internal\n    constructor(\n    /// The parse that this stack is part of @internal\n    p, \n    /// Holds state, input pos, buffer index triplets for all but the\n    /// top state @internal\n    stack, \n    /// The current parse state @internal\n    state, \n    // The position at which the next reduce should take place. This\n    // can be less than `this.pos` when skipped expressions have been\n    // added to the stack (which should be moved outside of the next\n    // reduction)\n    /// @internal\n    reducePos, \n    /// The input position up to which this stack has parsed.\n    pos, \n    /// The dynamic score of the stack, including dynamic precedence\n    /// and error-recovery penalties\n    /// @internal\n    score, \n    // The output buffer. Holds (type, start, end, size) quads\n    // representing nodes created by the parser, where `size` is\n    // amount of buffer array entries covered by this node.\n    /// @internal\n    buffer, \n    // The base offset of the buffer. When stacks are split, the split\n    // instance shared the buffer history with its parent up to\n    // `bufferBase`, which is the absolute offset (including the\n    // offset of previous splits) into the buffer at which this stack\n    // starts writing.\n    /// @internal\n    bufferBase, \n    /// @internal\n    curContext, \n    /// @internal\n    lookAhead = 0, \n    // A parent stack from which this was split off, if any. This is\n    // set up so that it always points to a stack that has some\n    // additional buffer content, never to a stack with an equal\n    // `bufferBase`.\n    /// @internal\n    parent) {\n        this.p = p;\n        this.stack = stack;\n        this.state = state;\n        this.reducePos = reducePos;\n        this.pos = pos;\n        this.score = score;\n        this.buffer = buffer;\n        this.bufferBase = bufferBase;\n        this.curContext = curContext;\n        this.lookAhead = lookAhead;\n        this.parent = parent;\n    }\n    /// @internal\n    toString() {\n        return `[${this.stack.filter((_, i) => i % 3 == 0).concat(this.state)}]@${this.pos}${this.score ? \"!\" + this.score : \"\"}`;\n    }\n    // Start an empty stack\n    /// @internal\n    static start(p, state, pos = 0) {\n        let cx = p.parser.context;\n        return new Stack(p, [], state, pos, pos, 0, [], 0, cx ? new StackContext(cx, cx.start) : null, 0, null);\n    }\n    /// The stack's current [context](#lr.ContextTracker) value, if\n    /// any. Its type will depend on the context tracker's type\n    /// parameter, or it will be `null` if there is no context\n    /// tracker.\n    get context() { return this.curContext ? this.curContext.context : null; }\n    // Push a state onto the stack, tracking its start position as well\n    // as the buffer base at that point.\n    /// @internal\n    pushState(state, start) {\n        this.stack.push(this.state, start, this.bufferBase + this.buffer.length);\n        this.state = state;\n    }\n    // Apply a reduce action\n    /// @internal\n    reduce(action) {\n        let depth = action >> 19 /* ReduceDepthShift */, type = action & 65535 /* ValueMask */;\n        let { parser } = this.p;\n        let dPrec = parser.dynamicPrecedence(type);\n        if (dPrec)\n            this.score += dPrec;\n        if (depth == 0) {\n            // Zero-depth reductions are a special case—they add stuff to\n            // the stack without popping anything off.\n            if (type < parser.minRepeatTerm)\n                this.storeNode(type, this.reducePos, this.reducePos, 4, true);\n            this.pushState(parser.getGoto(this.state, type, true), this.reducePos);\n            this.reduceContext(type, this.reducePos);\n            return;\n        }\n        // Find the base index into `this.stack`, content after which will\n        // be dropped. Note that with `StayFlag` reductions we need to\n        // consume two extra frames (the dummy parent node for the skipped\n        // expression and the state that we'll be staying in, which should\n        // be moved to `this.state`).\n        let base = this.stack.length - ((depth - 1) * 3) - (action & 262144 /* StayFlag */ ? 6 : 0);\n        let start = this.stack[base - 2];\n        let bufferBase = this.stack[base - 1], count = this.bufferBase + this.buffer.length - bufferBase;\n        // Store normal terms or `R -> R R` repeat reductions\n        if (type < parser.minRepeatTerm || (action & 131072 /* RepeatFlag */)) {\n            let pos = parser.stateFlag(this.state, 1 /* Skipped */) ? this.pos : this.reducePos;\n            this.storeNode(type, start, pos, count + 4, true);\n        }\n        if (action & 262144 /* StayFlag */) {\n            this.state = this.stack[base];\n        }\n        else {\n            let baseStateID = this.stack[base - 3];\n            this.state = parser.getGoto(baseStateID, type, true);\n        }\n        while (this.stack.length > base)\n            this.stack.pop();\n        this.reduceContext(type, start);\n    }\n    // Shift a value into the buffer\n    /// @internal\n    storeNode(term, start, end, size = 4, isReduce = false) {\n        if (term == 0 /* Err */) { // Try to omit/merge adjacent error nodes\n            let cur = this, top = this.buffer.length;\n            if (top == 0 && cur.parent) {\n                top = cur.bufferBase - cur.parent.bufferBase;\n                cur = cur.parent;\n            }\n            if (top > 0 && cur.buffer[top - 4] == 0 /* Err */ && cur.buffer[top - 1] > -1) {\n                if (start == end)\n                    return;\n                if (cur.buffer[top - 2] >= start) {\n                    cur.buffer[top - 2] = end;\n                    return;\n                }\n            }\n        }\n        if (!isReduce || this.pos == end) { // Simple case, just append\n            this.buffer.push(term, start, end, size);\n        }\n        else { // There may be skipped nodes that have to be moved forward\n            let index = this.buffer.length;\n            if (index > 0 && this.buffer[index - 4] != 0 /* Err */)\n                while (index > 0 && this.buffer[index - 2] > end) {\n                    // Move this record forward\n                    this.buffer[index] = this.buffer[index - 4];\n                    this.buffer[index + 1] = this.buffer[index - 3];\n                    this.buffer[index + 2] = this.buffer[index - 2];\n                    this.buffer[index + 3] = this.buffer[index - 1];\n                    index -= 4;\n                    if (size > 4)\n                        size -= 4;\n                }\n            this.buffer[index] = term;\n            this.buffer[index + 1] = start;\n            this.buffer[index + 2] = end;\n            this.buffer[index + 3] = size;\n        }\n    }\n    // Apply a shift action\n    /// @internal\n    shift(action, next, nextEnd) {\n        let start = this.pos;\n        if (action & 131072 /* GotoFlag */) {\n            this.pushState(action & 65535 /* ValueMask */, this.pos);\n        }\n        else if ((action & 262144 /* StayFlag */) == 0) { // Regular shift\n            let nextState = action, { parser } = this.p;\n            if (nextEnd > this.pos || next <= parser.maxNode) {\n                this.pos = nextEnd;\n                if (!parser.stateFlag(nextState, 1 /* Skipped */))\n                    this.reducePos = nextEnd;\n            }\n            this.pushState(nextState, start);\n            this.shiftContext(next, start);\n            if (next <= parser.maxNode)\n                this.buffer.push(next, start, nextEnd, 4);\n        }\n        else { // Shift-and-stay, which means this is a skipped token\n            this.pos = nextEnd;\n            this.shiftContext(next, start);\n            if (next <= this.p.parser.maxNode)\n                this.buffer.push(next, start, nextEnd, 4);\n        }\n    }\n    // Apply an action\n    /// @internal\n    apply(action, next, nextEnd) {\n        if (action & 65536 /* ReduceFlag */)\n            this.reduce(action);\n        else\n            this.shift(action, next, nextEnd);\n    }\n    // Add a prebuilt (reused) node into the buffer.\n    /// @internal\n    useNode(value, next) {\n        let index = this.p.reused.length - 1;\n        if (index < 0 || this.p.reused[index] != value) {\n            this.p.reused.push(value);\n            index++;\n        }\n        let start = this.pos;\n        this.reducePos = this.pos = start + value.length;\n        this.pushState(next, start);\n        this.buffer.push(index, start, this.reducePos, -1 /* size == -1 means this is a reused value */);\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.reuse(this.curContext.context, value, this, this.p.stream.reset(this.pos - value.length)));\n    }\n    // Split the stack. Due to the buffer sharing and the fact\n    // that `this.stack` tends to stay quite shallow, this isn't very\n    // expensive.\n    /// @internal\n    split() {\n        let parent = this;\n        let off = parent.buffer.length;\n        // Because the top of the buffer (after this.pos) may be mutated\n        // to reorder reductions and skipped tokens, and shared buffers\n        // should be immutable, this copies any outstanding skipped tokens\n        // to the new buffer, and puts the base pointer before them.\n        while (off > 0 && parent.buffer[off - 2] > parent.reducePos)\n            off -= 4;\n        let buffer = parent.buffer.slice(off), base = parent.bufferBase + off;\n        // Make sure parent points to an actual parent with content, if there is such a parent.\n        while (parent && base == parent.bufferBase)\n            parent = parent.parent;\n        return new Stack(this.p, this.stack.slice(), this.state, this.reducePos, this.pos, this.score, buffer, base, this.curContext, this.lookAhead, parent);\n    }\n    // Try to recover from an error by 'deleting' (ignoring) one token.\n    /// @internal\n    recoverByDelete(next, nextEnd) {\n        let isNode = next <= this.p.parser.maxNode;\n        if (isNode)\n            this.storeNode(next, this.pos, nextEnd, 4);\n        this.storeNode(0 /* Err */, this.pos, nextEnd, isNode ? 8 : 4);\n        this.pos = this.reducePos = nextEnd;\n        this.score -= 190 /* Delete */;\n    }\n    /// Check if the given term would be able to be shifted (optionally\n    /// after some reductions) on this stack. This can be useful for\n    /// external tokenizers that want to make sure they only provide a\n    /// given token when it applies.\n    canShift(term) {\n        for (let sim = new SimulatedStack(this);;) {\n            let action = this.p.parser.stateSlot(sim.state, 4 /* DefaultReduce */) || this.p.parser.hasAction(sim.state, term);\n            if ((action & 65536 /* ReduceFlag */) == 0)\n                return true;\n            if (action == 0)\n                return false;\n            sim.reduce(action);\n        }\n    }\n    // Apply up to Recover.MaxNext recovery actions that conceptually\n    // inserts some missing token or rule.\n    /// @internal\n    recoverByInsert(next) {\n        if (this.stack.length >= 300 /* MaxInsertStackDepth */)\n            return [];\n        let nextStates = this.p.parser.nextStates(this.state);\n        if (nextStates.length > 4 /* MaxNext */ << 1 || this.stack.length >= 120 /* DampenInsertStackDepth */) {\n            let best = [];\n            for (let i = 0, s; i < nextStates.length; i += 2) {\n                if ((s = nextStates[i + 1]) != this.state && this.p.parser.hasAction(s, next))\n                    best.push(nextStates[i], s);\n            }\n            if (this.stack.length < 120 /* DampenInsertStackDepth */)\n                for (let i = 0; best.length < 4 /* MaxNext */ << 1 && i < nextStates.length; i += 2) {\n                    let s = nextStates[i + 1];\n                    if (!best.some((v, i) => (i & 1) && v == s))\n                        best.push(nextStates[i], s);\n                }\n            nextStates = best;\n        }\n        let result = [];\n        for (let i = 0; i < nextStates.length && result.length < 4 /* MaxNext */; i += 2) {\n            let s = nextStates[i + 1];\n            if (s == this.state)\n                continue;\n            let stack = this.split();\n            stack.storeNode(0 /* Err */, stack.pos, stack.pos, 4, true);\n            stack.pushState(s, this.pos);\n            stack.shiftContext(nextStates[i], this.pos);\n            stack.score -= 200 /* Insert */;\n            result.push(stack);\n        }\n        return result;\n    }\n    // Force a reduce, if possible. Return false if that can't\n    // be done.\n    /// @internal\n    forceReduce() {\n        let reduce = this.p.parser.stateSlot(this.state, 5 /* ForcedReduce */);\n        if ((reduce & 65536 /* ReduceFlag */) == 0)\n            return false;\n        let { parser } = this.p;\n        if (!parser.validAction(this.state, reduce)) {\n            let depth = reduce >> 19 /* ReduceDepthShift */, term = reduce & 65535 /* ValueMask */;\n            let target = this.stack.length - depth * 3;\n            if (target < 0 || parser.getGoto(this.stack[target], term, false) < 0)\n                return false;\n            this.storeNode(0 /* Err */, this.reducePos, this.reducePos, 4, true);\n            this.score -= 100 /* Reduce */;\n        }\n        this.reduce(reduce);\n        return true;\n    }\n    /// @internal\n    forceAll() {\n        while (!this.p.parser.stateFlag(this.state, 2 /* Accepting */)) {\n            if (!this.forceReduce()) {\n                this.storeNode(0 /* Err */, this.pos, this.pos, 4, true);\n                break;\n            }\n        }\n        return this;\n    }\n    /// Check whether this state has no further actions (assumed to be a direct descendant of the\n    /// top state, since any other states must be able to continue\n    /// somehow). @internal\n    get deadEnd() {\n        if (this.stack.length != 3)\n            return false;\n        let { parser } = this.p;\n        return parser.data[parser.stateSlot(this.state, 1 /* Actions */)] == 65535 /* End */ &&\n            !parser.stateSlot(this.state, 4 /* DefaultReduce */);\n    }\n    /// Restart the stack (put it back in its start state). Only safe\n    /// when this.stack.length == 3 (state is directly below the top\n    /// state). @internal\n    restart() {\n        this.state = this.stack[0];\n        this.stack.length = 0;\n    }\n    /// @internal\n    sameState(other) {\n        if (this.state != other.state || this.stack.length != other.stack.length)\n            return false;\n        for (let i = 0; i < this.stack.length; i += 3)\n            if (this.stack[i] != other.stack[i])\n                return false;\n        return true;\n    }\n    /// Get the parser used by this stack.\n    get parser() { return this.p.parser; }\n    /// Test whether a given dialect (by numeric ID, as exported from\n    /// the terms file) is enabled.\n    dialectEnabled(dialectID) { return this.p.parser.dialect.flags[dialectID]; }\n    shiftContext(term, start) {\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.shift(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    reduceContext(term, start) {\n        if (this.curContext)\n            this.updateContext(this.curContext.tracker.reduce(this.curContext.context, term, this, this.p.stream.reset(start)));\n    }\n    /// @internal\n    emitContext() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -3)\n            this.buffer.push(this.curContext.hash, this.reducePos, this.reducePos, -3);\n    }\n    /// @internal\n    emitLookAhead() {\n        let last = this.buffer.length - 1;\n        if (last < 0 || this.buffer[last] != -4)\n            this.buffer.push(this.lookAhead, this.reducePos, this.reducePos, -4);\n    }\n    updateContext(context) {\n        if (context != this.curContext.context) {\n            let newCx = new StackContext(this.curContext.tracker, context);\n            if (newCx.hash != this.curContext.hash)\n                this.emitContext();\n            this.curContext = newCx;\n        }\n    }\n    /// @internal\n    setLookAhead(lookAhead) {\n        if (lookAhead > this.lookAhead) {\n            this.emitLookAhead();\n            this.lookAhead = lookAhead;\n        }\n    }\n    /// @internal\n    close() {\n        if (this.curContext && this.curContext.tracker.strict)\n            this.emitContext();\n        if (this.lookAhead > 0)\n            this.emitLookAhead();\n    }\n}\nclass StackContext {\n    constructor(tracker, context) {\n        this.tracker = tracker;\n        this.context = context;\n        this.hash = tracker.strict ? tracker.hash(context) : 0;\n    }\n}\nvar Recover;\n(function (Recover) {\n    Recover[Recover[\"Insert\"] = 200] = \"Insert\";\n    Recover[Recover[\"Delete\"] = 190] = \"Delete\";\n    Recover[Recover[\"Reduce\"] = 100] = \"Reduce\";\n    Recover[Recover[\"MaxNext\"] = 4] = \"MaxNext\";\n    Recover[Recover[\"MaxInsertStackDepth\"] = 300] = \"MaxInsertStackDepth\";\n    Recover[Recover[\"DampenInsertStackDepth\"] = 120] = \"DampenInsertStackDepth\";\n})(Recover || (Recover = {}));\n// Used to cheaply run some reductions to scan ahead without mutating\n// an entire stack\nclass SimulatedStack {\n    constructor(start) {\n        this.start = start;\n        this.state = start.state;\n        this.stack = start.stack;\n        this.base = this.stack.length;\n    }\n    reduce(action) {\n        let term = action & 65535 /* ValueMask */, depth = action >> 19 /* ReduceDepthShift */;\n        if (depth == 0) {\n            if (this.stack == this.start.stack)\n                this.stack = this.stack.slice();\n            this.stack.push(this.state, 0, 0);\n            this.base += 3;\n        }\n        else {\n            this.base -= (depth - 1) * 3;\n        }\n        let goto = this.start.p.parser.getGoto(this.stack[this.base - 3], term, true);\n        this.state = goto;\n    }\n}\n// This is given to `Tree.build` to build a buffer, and encapsulates\n// the parent-stack-walking necessary to read the nodes.\nclass StackBufferCursor {\n    constructor(stack, pos, index) {\n        this.stack = stack;\n        this.pos = pos;\n        this.index = index;\n        this.buffer = stack.buffer;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    static create(stack, pos = stack.bufferBase + stack.buffer.length) {\n        return new StackBufferCursor(stack, pos, pos - stack.bufferBase);\n    }\n    maybeNext() {\n        let next = this.stack.parent;\n        if (next != null) {\n            this.index = this.stack.bufferBase - next.bufferBase;\n            this.stack = next;\n            this.buffer = next.buffer;\n        }\n    }\n    get id() { return this.buffer[this.index - 4]; }\n    get start() { return this.buffer[this.index - 3]; }\n    get end() { return this.buffer[this.index - 2]; }\n    get size() { return this.buffer[this.index - 1]; }\n    next() {\n        this.index -= 4;\n        this.pos -= 4;\n        if (this.index == 0)\n            this.maybeNext();\n    }\n    fork() {\n        return new StackBufferCursor(this.stack, this.pos, this.index);\n    }\n}\n\nclass CachedToken {\n    constructor() {\n        this.start = -1;\n        this.value = -1;\n        this.end = -1;\n        this.extended = -1;\n        this.lookAhead = 0;\n        this.mask = 0;\n        this.context = 0;\n    }\n}\nconst nullToken = new CachedToken;\n/// [Tokenizers](#lr.ExternalTokenizer) interact with the input\n/// through this interface. It presents the input as a stream of\n/// characters, tracking lookahead and hiding the complexity of\n/// [ranges](#common.Parser.parse^ranges) from tokenizer code.\nclass InputStream {\n    /// @internal\n    constructor(\n    /// @internal\n    input, \n    /// @internal\n    ranges) {\n        this.input = input;\n        this.ranges = ranges;\n        /// @internal\n        this.chunk = \"\";\n        /// @internal\n        this.chunkOff = 0;\n        /// Backup chunk\n        this.chunk2 = \"\";\n        this.chunk2Pos = 0;\n        /// The character code of the next code unit in the input, or -1\n        /// when the stream is at the end of the input.\n        this.next = -1;\n        /// @internal\n        this.token = nullToken;\n        this.rangeIndex = 0;\n        this.pos = this.chunkPos = ranges[0].from;\n        this.range = ranges[0];\n        this.end = ranges[ranges.length - 1].to;\n        this.readNext();\n    }\n    resolveOffset(offset, assoc) {\n        let range = this.range, index = this.rangeIndex;\n        let pos = this.pos + offset;\n        while (pos < range.from) {\n            if (!index)\n                return null;\n            let next = this.ranges[--index];\n            pos -= range.from - next.to;\n            range = next;\n        }\n        while (assoc < 0 ? pos > range.to : pos >= range.to) {\n            if (index == this.ranges.length - 1)\n                return null;\n            let next = this.ranges[++index];\n            pos += next.from - range.to;\n            range = next;\n        }\n        return pos;\n    }\n    /// Look at a code unit near the stream position. `.peek(0)` equals\n    /// `.next`, `.peek(-1)` gives you the previous character, and so\n    /// on.\n    ///\n    /// Note that looking around during tokenizing creates dependencies\n    /// on potentially far-away content, which may reduce the\n    /// effectiveness incremental parsing—when looking forward—or even\n    /// cause invalid reparses when looking backward more than 25 code\n    /// units, since the library does not track lookbehind.\n    peek(offset) {\n        let idx = this.chunkOff + offset, pos, result;\n        if (idx >= 0 && idx < this.chunk.length) {\n            pos = this.pos + offset;\n            result = this.chunk.charCodeAt(idx);\n        }\n        else {\n            let resolved = this.resolveOffset(offset, 1);\n            if (resolved == null)\n                return -1;\n            pos = resolved;\n            if (pos >= this.chunk2Pos && pos < this.chunk2Pos + this.chunk2.length) {\n                result = this.chunk2.charCodeAt(pos - this.chunk2Pos);\n            }\n            else {\n                let i = this.rangeIndex, range = this.range;\n                while (range.to <= pos)\n                    range = this.ranges[++i];\n                this.chunk2 = this.input.chunk(this.chunk2Pos = pos);\n                if (pos + this.chunk2.length > range.to)\n                    this.chunk2 = this.chunk2.slice(0, range.to - pos);\n                result = this.chunk2.charCodeAt(0);\n            }\n        }\n        if (pos >= this.token.lookAhead)\n            this.token.lookAhead = pos + 1;\n        return result;\n    }\n    /// Accept a token. By default, the end of the token is set to the\n    /// current stream position, but you can pass an offset (relative to\n    /// the stream position) to change that.\n    acceptToken(token, endOffset = 0) {\n        let end = endOffset ? this.resolveOffset(endOffset, -1) : this.pos;\n        if (end == null || end < this.token.start)\n            throw new RangeError(\"Token end out of bounds\");\n        this.token.value = token;\n        this.token.end = end;\n    }\n    getChunk() {\n        if (this.pos >= this.chunk2Pos && this.pos < this.chunk2Pos + this.chunk2.length) {\n            let { chunk, chunkPos } = this;\n            this.chunk = this.chunk2;\n            this.chunkPos = this.chunk2Pos;\n            this.chunk2 = chunk;\n            this.chunk2Pos = chunkPos;\n            this.chunkOff = this.pos - this.chunkPos;\n        }\n        else {\n            this.chunk2 = this.chunk;\n            this.chunk2Pos = this.chunkPos;\n            let nextChunk = this.input.chunk(this.pos);\n            let end = this.pos + nextChunk.length;\n            this.chunk = end > this.range.to ? nextChunk.slice(0, this.range.to - this.pos) : nextChunk;\n            this.chunkPos = this.pos;\n            this.chunkOff = 0;\n        }\n    }\n    readNext() {\n        if (this.chunkOff >= this.chunk.length) {\n            this.getChunk();\n            if (this.chunkOff == this.chunk.length)\n                return this.next = -1;\n        }\n        return this.next = this.chunk.charCodeAt(this.chunkOff);\n    }\n    /// Move the stream forward N (defaults to 1) code units. Returns\n    /// the new value of [`next`](#lr.InputStream.next).\n    advance(n = 1) {\n        this.chunkOff += n;\n        while (this.pos + n >= this.range.to) {\n            if (this.rangeIndex == this.ranges.length - 1)\n                return this.setDone();\n            n -= this.range.to - this.pos;\n            this.range = this.ranges[++this.rangeIndex];\n            this.pos = this.range.from;\n        }\n        this.pos += n;\n        if (this.pos >= this.token.lookAhead)\n            this.token.lookAhead = this.pos + 1;\n        return this.readNext();\n    }\n    setDone() {\n        this.pos = this.chunkPos = this.end;\n        this.range = this.ranges[this.rangeIndex = this.ranges.length - 1];\n        this.chunk = \"\";\n        return this.next = -1;\n    }\n    /// @internal\n    reset(pos, token) {\n        if (token) {\n            this.token = token;\n            token.start = pos;\n            token.lookAhead = pos + 1;\n            token.value = token.extended = -1;\n        }\n        else {\n            this.token = nullToken;\n        }\n        if (this.pos != pos) {\n            this.pos = pos;\n            if (pos == this.end) {\n                this.setDone();\n                return this;\n            }\n            while (pos < this.range.from)\n                this.range = this.ranges[--this.rangeIndex];\n            while (pos >= this.range.to)\n                this.range = this.ranges[++this.rangeIndex];\n            if (pos >= this.chunkPos && pos < this.chunkPos + this.chunk.length) {\n                this.chunkOff = pos - this.chunkPos;\n            }\n            else {\n                this.chunk = \"\";\n                this.chunkOff = 0;\n            }\n            this.readNext();\n        }\n        return this;\n    }\n    /// @internal\n    read(from, to) {\n        if (from >= this.chunkPos && to <= this.chunkPos + this.chunk.length)\n            return this.chunk.slice(from - this.chunkPos, to - this.chunkPos);\n        if (from >= this.range.from && to <= this.range.to)\n            return this.input.read(from, to);\n        let result = \"\";\n        for (let r of this.ranges) {\n            if (r.from >= to)\n                break;\n            if (r.to > from)\n                result += this.input.read(Math.max(r.from, from), Math.min(r.to, to));\n        }\n        return result;\n    }\n}\n/// @internal\nclass TokenGroup {\n    constructor(data, id) {\n        this.data = data;\n        this.id = id;\n    }\n    token(input, stack) { readToken(this.data, input, stack, this.id); }\n}\nTokenGroup.prototype.contextual = TokenGroup.prototype.fallback = TokenGroup.prototype.extend = false;\n/// `@external tokens` declarations in the grammar should resolve to\n/// an instance of this class.\nclass ExternalTokenizer {\n    /// Create a tokenizer. The first argument is the function that,\n    /// given an input stream, scans for the types of tokens it\n    /// recognizes at the stream's position, and calls\n    /// [`acceptToken`](#lr.InputStream.acceptToken) when it finds\n    /// one.\n    constructor(\n    /// @internal\n    token, options = {}) {\n        this.token = token;\n        this.contextual = !!options.contextual;\n        this.fallback = !!options.fallback;\n        this.extend = !!options.extend;\n    }\n}\n// Tokenizer data is stored a big uint16 array containing, for each\n// state:\n//\n//  - A group bitmask, indicating what token groups are reachable from\n//    this state, so that paths that can only lead to tokens not in\n//    any of the current groups can be cut off early.\n//\n//  - The position of the end of the state's sequence of accepting\n//    tokens\n//\n//  - The number of outgoing edges for the state\n//\n//  - The accepting tokens, as (token id, group mask) pairs\n//\n//  - The outgoing edges, as (start character, end character, state\n//    index) triples, with end character being exclusive\n//\n// This function interprets that data, running through a stream as\n// long as new states with the a matching group mask can be reached,\n// and updating `token` when it matches a token.\nfunction readToken(data, input, stack, group) {\n    let state = 0, groupMask = 1 << group, { parser } = stack.p, { dialect } = parser;\n    scan: for (;;) {\n        if ((groupMask & data[state]) == 0)\n            break;\n        let accEnd = data[state + 1];\n        // Check whether this state can lead to a token in the current group\n        // Accept tokens in this state, possibly overwriting\n        // lower-precedence / shorter tokens\n        for (let i = state + 3; i < accEnd; i += 2)\n            if ((data[i + 1] & groupMask) > 0) {\n                let term = data[i];\n                if (dialect.allows(term) &&\n                    (input.token.value == -1 || input.token.value == term || parser.overrides(term, input.token.value))) {\n                    input.acceptToken(term);\n                    break;\n                }\n            }\n        // Do a binary search on the state's edges\n        for (let next = input.next, low = 0, high = data[state + 2]; low < high;) {\n            let mid = (low + high) >> 1;\n            let index = accEnd + mid + (mid << 1);\n            let from = data[index], to = data[index + 1];\n            if (next < from)\n                high = mid;\n            else if (next >= to)\n                low = mid + 1;\n            else {\n                state = data[index + 2];\n                input.advance();\n                continue scan;\n            }\n        }\n        break;\n    }\n}\n\n// See lezer-generator/src/encode.ts for comments about the encoding\n// used here\nfunction decodeArray(input, Type = Uint16Array) {\n    if (typeof input != \"string\")\n        return input;\n    let array = null;\n    for (let pos = 0, out = 0; pos < input.length;) {\n        let value = 0;\n        for (;;) {\n            let next = input.charCodeAt(pos++), stop = false;\n            if (next == 126 /* BigValCode */) {\n                value = 65535 /* BigVal */;\n                break;\n            }\n            if (next >= 92 /* Gap2 */)\n                next--;\n            if (next >= 34 /* Gap1 */)\n                next--;\n            let digit = next - 32 /* Start */;\n            if (digit >= 46 /* Base */) {\n                digit -= 46 /* Base */;\n                stop = true;\n            }\n            value += digit;\n            if (stop)\n                break;\n            value *= 46 /* Base */;\n        }\n        if (array)\n            array[out++] = value;\n        else\n            array = new Type(value);\n    }\n    return array;\n}\n\n// FIXME find some way to reduce recovery work done when the input\n// doesn't match the grammar at all.\n// Environment variable used to control console output\nconst verbose = typeof process != \"undefined\" && /\\bparse\\b/.test(process.env.LOG);\nlet stackIDs = null;\nvar Safety;\n(function (Safety) {\n    Safety[Safety[\"Margin\"] = 25] = \"Margin\";\n})(Safety || (Safety = {}));\nfunction cutAt(tree, pos, side) {\n    let cursor = tree.fullCursor();\n    cursor.moveTo(pos);\n    for (;;) {\n        if (!(side < 0 ? cursor.childBefore(pos) : cursor.childAfter(pos)))\n            for (;;) {\n                if ((side < 0 ? cursor.to < pos : cursor.from > pos) && !cursor.type.isError)\n                    return side < 0 ? Math.max(0, Math.min(cursor.to - 1, pos - 25 /* Margin */))\n                        : Math.min(tree.length, Math.max(cursor.from + 1, pos + 25 /* Margin */));\n                if (side < 0 ? cursor.prevSibling() : cursor.nextSibling())\n                    break;\n                if (!cursor.parent())\n                    return side < 0 ? 0 : tree.length;\n            }\n    }\n}\nclass FragmentCursor {\n    constructor(fragments, nodeSet) {\n        this.fragments = fragments;\n        this.nodeSet = nodeSet;\n        this.i = 0;\n        this.fragment = null;\n        this.safeFrom = -1;\n        this.safeTo = -1;\n        this.trees = [];\n        this.start = [];\n        this.index = [];\n        this.nextFragment();\n    }\n    nextFragment() {\n        let fr = this.fragment = this.i == this.fragments.length ? null : this.fragments[this.i++];\n        if (fr) {\n            this.safeFrom = fr.openStart ? cutAt(fr.tree, fr.from + fr.offset, 1) - fr.offset : fr.from;\n            this.safeTo = fr.openEnd ? cutAt(fr.tree, fr.to + fr.offset, -1) - fr.offset : fr.to;\n            while (this.trees.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n            }\n            this.trees.push(fr.tree);\n            this.start.push(-fr.offset);\n            this.index.push(0);\n            this.nextStart = this.safeFrom;\n        }\n        else {\n            this.nextStart = 1e9;\n        }\n    }\n    // `pos` must be >= any previously given `pos` for this cursor\n    nodeAt(pos) {\n        if (pos < this.nextStart)\n            return null;\n        while (this.fragment && this.safeTo <= pos)\n            this.nextFragment();\n        if (!this.fragment)\n            return null;\n        for (;;) {\n            let last = this.trees.length - 1;\n            if (last < 0) { // End of tree\n                this.nextFragment();\n                return null;\n            }\n            let top = this.trees[last], index = this.index[last];\n            if (index == top.children.length) {\n                this.trees.pop();\n                this.start.pop();\n                this.index.pop();\n                continue;\n            }\n            let next = top.children[index];\n            let start = this.start[last] + top.positions[index];\n            if (start > pos) {\n                this.nextStart = start;\n                return null;\n            }\n            if (next instanceof Tree) {\n                if (start == pos) {\n                    if (start < this.safeFrom)\n                        return null;\n                    let end = start + next.length;\n                    if (end <= this.safeTo) {\n                        let lookAhead = next.prop(NodeProp.lookAhead);\n                        if (!lookAhead || end + lookAhead < this.fragment.to)\n                            return next;\n                    }\n                }\n                this.index[last]++;\n                if (start + next.length >= Math.max(this.safeFrom, pos)) { // Enter this node\n                    this.trees.push(next);\n                    this.start.push(start);\n                    this.index.push(0);\n                }\n            }\n            else {\n                this.index[last]++;\n                this.nextStart = start + next.length;\n            }\n        }\n    }\n}\nclass TokenCache {\n    constructor(parser, stream) {\n        this.stream = stream;\n        this.tokens = [];\n        this.mainToken = null;\n        this.actions = [];\n        this.tokens = parser.tokenizers.map(_ => new CachedToken);\n    }\n    getActions(stack) {\n        let actionIndex = 0;\n        let main = null;\n        let { parser } = stack.p, { tokenizers } = parser;\n        let mask = parser.stateSlot(stack.state, 3 /* TokenizerMask */);\n        let context = stack.curContext ? stack.curContext.hash : 0;\n        let lookAhead = 0;\n        for (let i = 0; i < tokenizers.length; i++) {\n            if (((1 << i) & mask) == 0)\n                continue;\n            let tokenizer = tokenizers[i], token = this.tokens[i];\n            if (main && !tokenizer.fallback)\n                continue;\n            if (tokenizer.contextual || token.start != stack.pos || token.mask != mask || token.context != context) {\n                this.updateCachedToken(token, tokenizer, stack);\n                token.mask = mask;\n                token.context = context;\n            }\n            if (token.lookAhead > token.end + 25 /* Margin */)\n                lookAhead = Math.max(token.lookAhead, lookAhead);\n            if (token.value != 0 /* Err */) {\n                let startIndex = actionIndex;\n                if (token.extended > -1)\n                    actionIndex = this.addActions(stack, token.extended, token.end, actionIndex);\n                actionIndex = this.addActions(stack, token.value, token.end, actionIndex);\n                if (!tokenizer.extend) {\n                    main = token;\n                    if (actionIndex > startIndex)\n                        break;\n                }\n            }\n        }\n        while (this.actions.length > actionIndex)\n            this.actions.pop();\n        if (lookAhead)\n            stack.setLookAhead(lookAhead);\n        if (!main && stack.pos == this.stream.end) {\n            main = new CachedToken;\n            main.value = stack.p.parser.eofTerm;\n            main.start = main.end = stack.pos;\n            actionIndex = this.addActions(stack, main.value, main.end, actionIndex);\n        }\n        this.mainToken = main;\n        return this.actions;\n    }\n    getMainToken(stack) {\n        if (this.mainToken)\n            return this.mainToken;\n        let main = new CachedToken, { pos, p } = stack;\n        main.start = pos;\n        main.end = Math.min(pos + 1, p.stream.end);\n        main.value = pos == p.stream.end ? p.parser.eofTerm : 0 /* Err */;\n        return main;\n    }\n    updateCachedToken(token, tokenizer, stack) {\n        tokenizer.token(this.stream.reset(stack.pos, token), stack);\n        if (token.value > -1) {\n            let { parser } = stack.p;\n            for (let i = 0; i < parser.specialized.length; i++)\n                if (parser.specialized[i] == token.value) {\n                    let result = parser.specializers[i](this.stream.read(token.start, token.end), stack);\n                    if (result >= 0 && stack.p.parser.dialect.allows(result >> 1)) {\n                        if ((result & 1) == 0 /* Specialize */)\n                            token.value = result >> 1;\n                        else\n                            token.extended = result >> 1;\n                        break;\n                    }\n                }\n        }\n        else {\n            token.value = 0 /* Err */;\n            token.end = Math.min(stack.p.stream.end, stack.pos + 1);\n        }\n    }\n    putAction(action, token, end, index) {\n        // Don't add duplicate actions\n        for (let i = 0; i < index; i += 3)\n            if (this.actions[i] == action)\n                return index;\n        this.actions[index++] = action;\n        this.actions[index++] = token;\n        this.actions[index++] = end;\n        return index;\n    }\n    addActions(stack, token, end, index) {\n        let { state } = stack, { parser } = stack.p, { data } = parser;\n        for (let set = 0; set < 2; set++) {\n            for (let i = parser.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */);; i += 3) {\n                if (data[i] == 65535 /* End */) {\n                    if (data[i + 1] == 1 /* Next */) {\n                        i = pair(data, i + 2);\n                    }\n                    else {\n                        if (index == 0 && data[i + 1] == 2 /* Other */)\n                            index = this.putAction(pair(data, i + 1), token, end, index);\n                        break;\n                    }\n                }\n                if (data[i] == token)\n                    index = this.putAction(pair(data, i + 1), token, end, index);\n            }\n        }\n        return index;\n    }\n}\nvar Rec;\n(function (Rec) {\n    Rec[Rec[\"Distance\"] = 5] = \"Distance\";\n    Rec[Rec[\"MaxRemainingPerStep\"] = 3] = \"MaxRemainingPerStep\";\n    // When two stacks have been running independently long enough to\n    // add this many elements to their buffers, prune one.\n    Rec[Rec[\"MinBufferLengthPrune\"] = 500] = \"MinBufferLengthPrune\";\n    Rec[Rec[\"ForceReduceLimit\"] = 10] = \"ForceReduceLimit\";\n    // Once a stack reaches this depth (in .stack.length) force-reduce\n    // it back to CutTo to avoid creating trees that overflow the stack\n    // on recursive traversal.\n    Rec[Rec[\"CutDepth\"] = 15000] = \"CutDepth\";\n    Rec[Rec[\"CutTo\"] = 9000] = \"CutTo\";\n})(Rec || (Rec = {}));\nclass Parse {\n    constructor(parser, input, fragments, ranges) {\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.recovering = 0;\n        this.nextStackID = 0x2654; // ♔, ♕, ♖, ♗, ♘, ♙, ♠, ♡, ♢, ♣, ♤, ♥, ♦, ♧\n        this.minStackPos = 0;\n        this.reused = [];\n        this.stoppedAt = null;\n        this.stream = new InputStream(input, ranges);\n        this.tokens = new TokenCache(parser, this.stream);\n        this.topTerm = parser.top[1];\n        let { from } = ranges[0];\n        this.stacks = [Stack.start(this, parser.top[0], from)];\n        this.fragments = fragments.length && this.stream.end - from > parser.bufferLength * 4\n            ? new FragmentCursor(fragments, parser.nodeSet) : null;\n    }\n    get parsedPos() {\n        return this.minStackPos;\n    }\n    // Move the parser forward. This will process all parse stacks at\n    // `this.pos` and try to advance them to a further position. If no\n    // stack for such a position is found, it'll start error-recovery.\n    //\n    // When the parse is finished, this will return a syntax tree. When\n    // not, it returns `null`.\n    advance() {\n        let stacks = this.stacks, pos = this.minStackPos;\n        // This will hold stacks beyond `pos`.\n        let newStacks = this.stacks = [];\n        let stopped, stoppedTokens;\n        // Keep advancing any stacks at `pos` until they either move\n        // forward or can't be advanced. Gather stacks that can't be\n        // advanced further in `stopped`.\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i];\n            for (;;) {\n                this.tokens.mainToken = null;\n                if (stack.pos > pos) {\n                    newStacks.push(stack);\n                }\n                else if (this.advanceStack(stack, newStacks, stacks)) {\n                    continue;\n                }\n                else {\n                    if (!stopped) {\n                        stopped = [];\n                        stoppedTokens = [];\n                    }\n                    stopped.push(stack);\n                    let tok = this.tokens.getMainToken(stack);\n                    stoppedTokens.push(tok.value, tok.end);\n                }\n                break;\n            }\n        }\n        if (!newStacks.length) {\n            let finished = stopped && findFinished(stopped);\n            if (finished)\n                return this.stackToTree(finished);\n            if (this.parser.strict) {\n                if (verbose && stopped)\n                    console.log(\"Stuck with token \" + (this.tokens.mainToken ? this.parser.getName(this.tokens.mainToken.value) : \"none\"));\n                throw new SyntaxError(\"No parse at \" + pos);\n            }\n            if (!this.recovering)\n                this.recovering = 5 /* Distance */;\n        }\n        if (this.recovering && stopped) {\n            let finished = this.stoppedAt != null && stopped[0].pos > this.stoppedAt ? stopped[0]\n                : this.runRecovery(stopped, stoppedTokens, newStacks);\n            if (finished)\n                return this.stackToTree(finished.forceAll());\n        }\n        if (this.recovering) {\n            let maxRemaining = this.recovering == 1 ? 1 : this.recovering * 3 /* MaxRemainingPerStep */;\n            if (newStacks.length > maxRemaining) {\n                newStacks.sort((a, b) => b.score - a.score);\n                while (newStacks.length > maxRemaining)\n                    newStacks.pop();\n            }\n            if (newStacks.some(s => s.reducePos > pos))\n                this.recovering--;\n        }\n        else if (newStacks.length > 1) {\n            // Prune stacks that are in the same state, or that have been\n            // running without splitting for a while, to avoid getting stuck\n            // with multiple successful stacks running endlessly on.\n            outer: for (let i = 0; i < newStacks.length - 1; i++) {\n                let stack = newStacks[i];\n                for (let j = i + 1; j < newStacks.length; j++) {\n                    let other = newStacks[j];\n                    if (stack.sameState(other) ||\n                        stack.buffer.length > 500 /* MinBufferLengthPrune */ && other.buffer.length > 500 /* MinBufferLengthPrune */) {\n                        if (((stack.score - other.score) || (stack.buffer.length - other.buffer.length)) > 0) {\n                            newStacks.splice(j--, 1);\n                        }\n                        else {\n                            newStacks.splice(i--, 1);\n                            continue outer;\n                        }\n                    }\n                }\n            }\n        }\n        this.minStackPos = newStacks[0].pos;\n        for (let i = 1; i < newStacks.length; i++)\n            if (newStacks[i].pos < this.minStackPos)\n                this.minStackPos = newStacks[i].pos;\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos)\n            throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    // Returns an updated version of the given stack, or null if the\n    // stack can't advance normally. When `split` and `stacks` are\n    // given, stacks split off by ambiguous operations will be pushed to\n    // `split`, or added to `stacks` if they move `pos` forward.\n    advanceStack(stack, stacks, split) {\n        let start = stack.pos, { parser } = this;\n        let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n        if (this.stoppedAt != null && start > this.stoppedAt)\n            return stack.forceReduce() ? stack : null;\n        if (this.fragments) {\n            let strictCx = stack.curContext && stack.curContext.tracker.strict, cxHash = strictCx ? stack.curContext.hash : 0;\n            for (let cached = this.fragments.nodeAt(start); cached;) {\n                let match = this.parser.nodeSet.types[cached.type.id] == cached.type ? parser.getGoto(stack.state, cached.type.id) : -1;\n                if (match > -1 && cached.length && (!strictCx || (cached.prop(NodeProp.contextHash) || 0) == cxHash)) {\n                    stack.useNode(cached, match);\n                    if (verbose)\n                        console.log(base + this.stackID(stack) + ` (via reuse of ${parser.getName(cached.type.id)})`);\n                    return true;\n                }\n                if (!(cached instanceof Tree) || cached.children.length == 0 || cached.positions[0] > 0)\n                    break;\n                let inner = cached.children[0];\n                if (inner instanceof Tree && cached.positions[0] == 0)\n                    cached = inner;\n                else\n                    break;\n            }\n        }\n        let defaultReduce = parser.stateSlot(stack.state, 4 /* DefaultReduce */);\n        if (defaultReduce > 0) {\n            stack.reduce(defaultReduce);\n            if (verbose)\n                console.log(base + this.stackID(stack) + ` (via always-reduce ${parser.getName(defaultReduce & 65535 /* ValueMask */)})`);\n            return true;\n        }\n        if (stack.stack.length >= 15000 /* CutDepth */) {\n            while (stack.stack.length > 9000 /* CutTo */ && stack.forceReduce()) { }\n        }\n        let actions = this.tokens.getActions(stack);\n        for (let i = 0; i < actions.length;) {\n            let action = actions[i++], term = actions[i++], end = actions[i++];\n            let last = i == actions.length || !split;\n            let localStack = last ? stack : stack.split();\n            localStack.apply(action, term, end);\n            if (verbose)\n                console.log(base + this.stackID(localStack) + ` (via ${(action & 65536 /* ReduceFlag */) == 0 ? \"shift\"\n                    : `reduce of ${parser.getName(action & 65535 /* ValueMask */)}`} for ${parser.getName(term)} @ ${start}${localStack == stack ? \"\" : \", split\"})`);\n            if (last)\n                return true;\n            else if (localStack.pos > start)\n                stacks.push(localStack);\n            else\n                split.push(localStack);\n        }\n        return false;\n    }\n    // Advance a given stack forward as far as it will go. Returns the\n    // (possibly updated) stack if it got stuck, or null if it moved\n    // forward and was given to `pushStackDedup`.\n    advanceFully(stack, newStacks) {\n        let pos = stack.pos;\n        for (;;) {\n            if (!this.advanceStack(stack, null, null))\n                return false;\n            if (stack.pos > pos) {\n                pushStackDedup(stack, newStacks);\n                return true;\n            }\n        }\n    }\n    runRecovery(stacks, tokens, newStacks) {\n        let finished = null, restarted = false;\n        for (let i = 0; i < stacks.length; i++) {\n            let stack = stacks[i], token = tokens[i << 1], tokenEnd = tokens[(i << 1) + 1];\n            let base = verbose ? this.stackID(stack) + \" -> \" : \"\";\n            if (stack.deadEnd) {\n                if (restarted)\n                    continue;\n                restarted = true;\n                stack.restart();\n                if (verbose)\n                    console.log(base + this.stackID(stack) + \" (restarted)\");\n                let done = this.advanceFully(stack, newStacks);\n                if (done)\n                    continue;\n            }\n            let force = stack.split(), forceBase = base;\n            for (let j = 0; force.forceReduce() && j < 10 /* ForceReduceLimit */; j++) {\n                if (verbose)\n                    console.log(forceBase + this.stackID(force) + \" (via force-reduce)\");\n                let done = this.advanceFully(force, newStacks);\n                if (done)\n                    break;\n                if (verbose)\n                    forceBase = this.stackID(force) + \" -> \";\n            }\n            for (let insert of stack.recoverByInsert(token)) {\n                if (verbose)\n                    console.log(base + this.stackID(insert) + \" (via recover-insert)\");\n                this.advanceFully(insert, newStacks);\n            }\n            if (this.stream.end > stack.pos) {\n                if (tokenEnd == stack.pos) {\n                    tokenEnd++;\n                    token = 0 /* Err */;\n                }\n                stack.recoverByDelete(token, tokenEnd);\n                if (verbose)\n                    console.log(base + this.stackID(stack) + ` (via recover-delete ${this.parser.getName(token)})`);\n                pushStackDedup(stack, newStacks);\n            }\n            else if (!finished || finished.score < stack.score) {\n                finished = stack;\n            }\n        }\n        return finished;\n    }\n    // Convert the stack's buffer to a syntax tree.\n    stackToTree(stack) {\n        stack.close();\n        return Tree.build({ buffer: StackBufferCursor.create(stack),\n            nodeSet: this.parser.nodeSet,\n            topID: this.topTerm,\n            maxBufferLength: this.parser.bufferLength,\n            reused: this.reused,\n            start: this.ranges[0].from,\n            length: stack.pos - this.ranges[0].from,\n            minRepeatType: this.parser.minRepeatTerm });\n    }\n    stackID(stack) {\n        let id = (stackIDs || (stackIDs = new WeakMap)).get(stack);\n        if (!id)\n            stackIDs.set(stack, id = String.fromCodePoint(this.nextStackID++));\n        return id + stack;\n    }\n}\nfunction pushStackDedup(stack, newStacks) {\n    for (let i = 0; i < newStacks.length; i++) {\n        let other = newStacks[i];\n        if (other.pos == stack.pos && other.sameState(stack)) {\n            if (newStacks[i].score < stack.score)\n                newStacks[i] = stack;\n            return;\n        }\n    }\n    newStacks.push(stack);\n}\nclass Dialect {\n    constructor(source, flags, disabled) {\n        this.source = source;\n        this.flags = flags;\n        this.disabled = disabled;\n    }\n    allows(term) { return !this.disabled || this.disabled[term] == 0; }\n}\nconst id = x => x;\n/// Context trackers are used to track stateful context (such as\n/// indentation in the Python grammar, or parent elements in the XML\n/// grammar) needed by external tokenizers. You declare them in a\n/// grammar file as `@context exportName from \"module\"`.\n///\n/// Context values should be immutable, and can be updated (replaced)\n/// on shift or reduce actions.\n///\n/// The export used in a `@context` declaration should be of this\n/// type.\nclass ContextTracker {\n    /// Define a context tracker.\n    constructor(spec) {\n        this.start = spec.start;\n        this.shift = spec.shift || id;\n        this.reduce = spec.reduce || id;\n        this.reuse = spec.reuse || id;\n        this.hash = spec.hash || (() => 0);\n        this.strict = spec.strict !== false;\n    }\n}\n/// A parser holds the parse tables for a given grammar, as generated\n/// by `lezer-generator`.\nclass LRParser extends Parser {\n    /// @internal\n    constructor(spec) {\n        super();\n        /// @internal\n        this.wrappers = [];\n        if (spec.version != 13 /* Version */)\n            throw new RangeError(`Parser version (${spec.version}) doesn't match runtime version (${13 /* Version */})`);\n        let nodeNames = spec.nodeNames.split(\" \");\n        this.minRepeatTerm = nodeNames.length;\n        for (let i = 0; i < spec.repeatNodeCount; i++)\n            nodeNames.push(\"\");\n        let topTerms = Object.keys(spec.topRules).map(r => spec.topRules[r][1]);\n        let nodeProps = [];\n        for (let i = 0; i < nodeNames.length; i++)\n            nodeProps.push([]);\n        function setProp(nodeID, prop, value) {\n            nodeProps[nodeID].push([prop, prop.deserialize(String(value))]);\n        }\n        if (spec.nodeProps)\n            for (let propSpec of spec.nodeProps) {\n                let prop = propSpec[0];\n                for (let i = 1; i < propSpec.length;) {\n                    let next = propSpec[i++];\n                    if (next >= 0) {\n                        setProp(next, prop, propSpec[i++]);\n                    }\n                    else {\n                        let value = propSpec[i + -next];\n                        for (let j = -next; j > 0; j--)\n                            setProp(propSpec[i++], prop, value);\n                        i++;\n                    }\n                }\n            }\n        this.nodeSet = new NodeSet(nodeNames.map((name, i) => NodeType.define({\n            name: i >= this.minRepeatTerm ? undefined : name,\n            id: i,\n            props: nodeProps[i],\n            top: topTerms.indexOf(i) > -1,\n            error: i == 0,\n            skipped: spec.skippedNodes && spec.skippedNodes.indexOf(i) > -1\n        })));\n        this.strict = false;\n        this.bufferLength = DefaultBufferLength;\n        let tokenArray = decodeArray(spec.tokenData);\n        this.context = spec.context;\n        this.specialized = new Uint16Array(spec.specialized ? spec.specialized.length : 0);\n        this.specializers = [];\n        if (spec.specialized)\n            for (let i = 0; i < spec.specialized.length; i++) {\n                this.specialized[i] = spec.specialized[i].term;\n                this.specializers[i] = spec.specialized[i].get;\n            }\n        this.states = decodeArray(spec.states, Uint32Array);\n        this.data = decodeArray(spec.stateData);\n        this.goto = decodeArray(spec.goto);\n        this.maxTerm = spec.maxTerm;\n        this.tokenizers = spec.tokenizers.map(value => typeof value == \"number\" ? new TokenGroup(tokenArray, value) : value);\n        this.topRules = spec.topRules;\n        this.dialects = spec.dialects || {};\n        this.dynamicPrecedences = spec.dynamicPrecedences || null;\n        this.tokenPrecTable = spec.tokenPrec;\n        this.termNames = spec.termNames || null;\n        this.maxNode = this.nodeSet.types.length - 1;\n        this.dialect = this.parseDialect();\n        this.top = this.topRules[Object.keys(this.topRules)[0]];\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new Parse(this, input, fragments, ranges);\n        for (let w of this.wrappers)\n            parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /// Get a goto table entry @internal\n    getGoto(state, term, loose = false) {\n        let table = this.goto;\n        if (term >= table[0])\n            return -1;\n        for (let pos = table[term + 1];;) {\n            let groupTag = table[pos++], last = groupTag & 1;\n            let target = table[pos++];\n            if (last && loose)\n                return target;\n            for (let end = pos + (groupTag >> 1); pos < end; pos++)\n                if (table[pos] == state)\n                    return target;\n            if (last)\n                return -1;\n        }\n    }\n    /// Check if this state has an action for a given terminal @internal\n    hasAction(state, terminal) {\n        let data = this.data;\n        for (let set = 0; set < 2; set++) {\n            for (let i = this.stateSlot(state, set ? 2 /* Skip */ : 1 /* Actions */), next;; i += 3) {\n                if ((next = data[i]) == 65535 /* End */) {\n                    if (data[i + 1] == 1 /* Next */)\n                        next = data[i = pair(data, i + 2)];\n                    else if (data[i + 1] == 2 /* Other */)\n                        return pair(data, i + 2);\n                    else\n                        break;\n                }\n                if (next == terminal || next == 0 /* Err */)\n                    return pair(data, i + 1);\n            }\n        }\n        return 0;\n    }\n    /// @internal\n    stateSlot(state, slot) {\n        return this.states[(state * 6 /* Size */) + slot];\n    }\n    /// @internal\n    stateFlag(state, flag) {\n        return (this.stateSlot(state, 0 /* Flags */) & flag) > 0;\n    }\n    /// @internal\n    validAction(state, action) {\n        if (action == this.stateSlot(state, 4 /* DefaultReduce */))\n            return true;\n        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {\n            if (this.data[i] == 65535 /* End */) {\n                if (this.data[i + 1] == 1 /* Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    return false;\n            }\n            if (action == pair(this.data, i + 1))\n                return true;\n        }\n    }\n    /// Get the states that can follow this one through shift actions or\n    /// goto jumps. @internal\n    nextStates(state) {\n        let result = [];\n        for (let i = this.stateSlot(state, 1 /* Actions */);; i += 3) {\n            if (this.data[i] == 65535 /* End */) {\n                if (this.data[i + 1] == 1 /* Next */)\n                    i = pair(this.data, i + 2);\n                else\n                    break;\n            }\n            if ((this.data[i + 2] & (65536 /* ReduceFlag */ >> 16)) == 0) {\n                let value = this.data[i + 1];\n                if (!result.some((v, i) => (i & 1) && v == value))\n                    result.push(this.data[i], value);\n            }\n        }\n        return result;\n    }\n    /// @internal\n    overrides(token, prev) {\n        let iPrev = findOffset(this.data, this.tokenPrecTable, prev);\n        return iPrev < 0 || findOffset(this.data, this.tokenPrecTable, token) < iPrev;\n    }\n    /// Configure the parser. Returns a new parser instance that has the\n    /// given settings modified. Settings not provided in `config` are\n    /// kept from the original parser.\n    configure(config) {\n        // Hideous reflection-based kludge to make it easy to create a\n        // slightly modified copy of a parser.\n        let copy = Object.assign(Object.create(LRParser.prototype), this);\n        if (config.props)\n            copy.nodeSet = this.nodeSet.extend(...config.props);\n        if (config.top) {\n            let info = this.topRules[config.top];\n            if (!info)\n                throw new RangeError(`Invalid top rule name ${config.top}`);\n            copy.top = info;\n        }\n        if (config.tokenizers)\n            copy.tokenizers = this.tokenizers.map(t => {\n                let found = config.tokenizers.find(r => r.from == t);\n                return found ? found.to : t;\n            });\n        if (config.contextTracker)\n            copy.context = config.contextTracker;\n        if (config.dialect)\n            copy.dialect = this.parseDialect(config.dialect);\n        if (config.strict != null)\n            copy.strict = config.strict;\n        if (config.wrap)\n            copy.wrappers = copy.wrappers.concat(config.wrap);\n        if (config.bufferLength != null)\n            copy.bufferLength = config.bufferLength;\n        return copy;\n    }\n    /// Returns the name associated with a given term. This will only\n    /// work for all terms when the parser was generated with the\n    /// `--names` option. By default, only the names of tagged terms are\n    /// stored.\n    getName(term) {\n        return this.termNames ? this.termNames[term] : String(term <= this.maxNode && this.nodeSet.types[term].name || term);\n    }\n    /// The eof term id is always allocated directly after the node\n    /// types. @internal\n    get eofTerm() { return this.maxNode + 1; }\n    /// The type of top node produced by the parser.\n    get topNode() { return this.nodeSet.types[this.top[1]]; }\n    /// @internal\n    dynamicPrecedence(term) {\n        let prec = this.dynamicPrecedences;\n        return prec == null ? 0 : prec[term] || 0;\n    }\n    /// @internal\n    parseDialect(dialect) {\n        let values = Object.keys(this.dialects), flags = values.map(() => false);\n        if (dialect)\n            for (let part of dialect.split(\" \")) {\n                let id = values.indexOf(part);\n                if (id >= 0)\n                    flags[id] = true;\n            }\n        let disabled = null;\n        for (let i = 0; i < values.length; i++)\n            if (!flags[i]) {\n                for (let j = this.dialects[values[i]], id; (id = this.data[j++]) != 65535 /* End */;)\n                    (disabled || (disabled = new Uint8Array(this.maxTerm + 1)))[id] = 1;\n            }\n        return new Dialect(dialect, flags, disabled);\n    }\n    /// (used by the output of the parser generator) @internal\n    static deserialize(spec) {\n        return new LRParser(spec);\n    }\n}\nfunction pair(data, off) { return data[off] | (data[off + 1] << 16); }\nfunction findOffset(data, start, term) {\n    for (let i = start, next; (next = data[i]) != 65535 /* End */; i++)\n        if (next == term)\n            return i - start;\n    return -1;\n}\nfunction findFinished(stacks) {\n    let best = null;\n    for (let stack of stacks) {\n        let stopped = stack.p.stoppedAt;\n        if ((stack.pos == stack.p.stream.end || stopped != null && stack.pos > stopped) &&\n            stack.p.parser.stateFlag(stack.state, 2 /* Accepting */) &&\n            (!best || best.score < stack.score))\n            best = stack;\n    }\n    return best;\n}\n\nexport { ContextTracker, ExternalTokenizer, InputStream, LRParser, Stack };\n","import { LRParser } from '@lezer/lr';\nimport { NodeProp } from '@lezer/common';\n\n// This file was generated by lezer-generator. You probably shouldn't edit it.\nconst parser = LRParser.deserialize({\n  version: 13,\n  states: \"$bOVQPOOOOQO'#Cb'#CbOnQPO'#CeOvQPO'#CjOOQO'#Cp'#CpQOQPOOOOQO'#Cg'#CgO}QPO'#CfO!SQPO'#CrOOQO,59P,59PO![QPO,59PO!aQPO'#CuOOQO,59U,59UO!iQPO,59UOVQPO,59QOqQPO'#CkO!nQPO,59^OOQO1G.k1G.kOVQPO'#ClO!vQPO,59aOOQO1G.p1G.pOOQO1G.l1G.lOOQO,59V,59VOOQO-E6i-E6iOOQO,59W,59WOOQO-E6j-E6j\",\n  stateData: \"#O~OcOS~OQSORSOSSOTSOWQO]ROePO~OVXOeUO~O[[O~PVOg^O~Oh_OVfX~OVaO~OhbO[iX~O[dO~Oh_OVfa~OhbO[ia~O\",\n  goto: \"!kjPPPPPPkPPkqwPPk{!RPPP!XP!ePP!hXSOR^bQWQRf_TVQ_Q`WRg`QcZRicQTOQZRQe^RhbRYQR]R\",\n  nodeNames: \"⚠ JsonText True False Null Number String } { Object Property PropertyName ] [ Array\",\n  maxTerm: 25,\n  nodeProps: [\n    [NodeProp.openedBy, 7,\"{\",12,\"[\"],\n    [NodeProp.closedBy, 8,\"}\",13,\"]\"]\n  ],\n  skippedNodes: [0],\n  repeatNodeCount: 2,\n  tokenData: \"(p~RaXY!WYZ!W]^!Wpq!Wrs!]|}$i}!O$n!Q!R$w!R![&V![!]&h!}#O&m#P#Q&r#Y#Z&w#b#c'f#h#i'}#o#p(f#q#r(k~!]Oc~~!`Upq!]qr!]rs!rs#O!]#O#P!w#P~!]~!wOe~~!zXrs!]!P!Q!]#O#P!]#U#V!]#Y#Z!]#b#c!]#f#g!]#h#i!]#i#j#g~#jR!Q![#s!c!i#s#T#Z#s~#vR!Q![$P!c!i$P#T#Z$P~$SR!Q![$]!c!i$]#T#Z$]~$`R!Q![!]!c!i!]#T#Z!]~$nOh~~$qQ!Q!R$w!R![&V~$|RT~!O!P%V!g!h%k#X#Y%k~%YP!Q![%]~%bRT~!Q![%]!g!h%k#X#Y%k~%nR{|%w}!O%w!Q![%}~%zP!Q![%}~&SPT~!Q![%}~&[ST~!O!P%V!Q![&V!g!h%k#X#Y%k~&mOg~~&rO]~~&wO[~~&zP#T#U&}~'QP#`#a'T~'WP#g#h'Z~'^P#X#Y'a~'fOR~~'iP#i#j'l~'oP#`#a'r~'uP#`#a'x~'}OS~~(QP#f#g(T~(WP#i#j(Z~(^P#X#Y(a~(fOQ~~(kOW~~(pOV~\",\n  tokenizers: [0],\n  topRules: {\"JsonText\":[0,1]},\n  tokenPrec: 0\n});\n\nexport { parser };\n"],"names":["DefaultBufferLength","nextPropID","Range","from","to","this","NodeProp","config","id","perNode","deserialize","Error","match","RangeError","NodeType","type","result","undefined","closedBy","str","split","openedBy","group","contextHash","lookAhead","mounted","noProps","Object","create","name","props","flags","prop","indexOf","spec","length","top","skipped","error","src","Array","isArray","map","direct","f","node","groups","i","found","none","NodeSet","types","newTypes","newProps","source","add","assign","push","CachedNode","WeakMap","CachedInnerNode","Tree","children","positions","value","overlay","tree","toString","test","isError","JSON","stringify","pos","side","scope","get","topNode","cursor","TreeCursor","moveTo","set","_tree","TreeNode","resolveNode","enter","leave","c","mustLeave","isAnonymous","firstChild","nextSibling","parent","balanceRange","propValues","makeTree","data","buildTree","empty","FlatBufferCursor","buffer","index","TreeBuffer","childString","join","endIndex","startIndex","dir","pick","checkSide","startI","endI","b","copy","Uint16Array","j","enterUnfinishedNodesBefore","scan","childBefore","last","lastChild","prevSibling","overlays","_a","inner","_from","_parent","mode","e","next","start","findChild","BufferNode","BufferContext","hasChild","nextChild","buffers","rPos","val","nextSignificantParent","before","after","r","getChildren","cur","is","context","child","externalSibling","parentStart","slice","stack","bufferNode","yieldNode","n","unshift","yieldBuf","yield","enterChild","pop","d","sibling","atLastNode","move","cache","depth","some","ch","nodeSet","maxBufferLength","reused","minRepeatType","takeNode","minPos","inRepeat","end","size","lookAheadAtStart","startPos","maxSize","fork","skip","minStart","nodeSize","localSkipped","nodeStart","findBufferSize","endPos","copyToBuffer","localChildren","localPositions","localInRepeat","lastGroup","lastEnd","makeRepeatLeaf","reverse","make","lookAheadProp","lastI","makeBalanced","base","pair","concat","bufferStart","topID","nodeSizeCache","balanceType","mkTop","mkTree","total","maxChild","Math","ceil","divide","offset","groupFrom","groupStart","groupSize","nextSize","only","TreeFragment","openStart","openEnd","open","fragments","partial","changes","minGap","fI","nextF","cI","off","nextC","nextPos","fromA","cut","fFrom","max","fTo","min","toA","toB","Parser","input","ranges","StringInput","createParse","parse","startParse","done","advance","string","Recover","Stack","p","state","reducePos","score","bufferBase","curContext","filter","_","action","parser","dPrec","dynamicPrecedence","minRepeatTerm","storeNode","pushState","getGoto","reduceContext","count","stateFlag","baseStateID","term","isReduce","nextEnd","nextState","maxNode","shiftContext","reduce","shift","updateContext","tracker","reuse","stream","reset","isNode","sim","SimulatedStack","stateSlot","hasAction","nextStates","s","best","v","validAction","target","forceReduce","other","dialectID","dialect","hash","newCx","StackContext","emitContext","emitLookAhead","strict","cx","goto","StackBufferCursor","maybeNext","CachedToken","extended","mask","nullToken","InputStream","chunk","chunkOff","chunk2","chunk2Pos","token","rangeIndex","chunkPos","range","readNext","assoc","idx","charCodeAt","resolved","resolveOffset","endOffset","nextChunk","getChunk","setDone","read","TokenGroup","groupMask","accEnd","allows","overrides","acceptToken","low","high","mid","readToken","prototype","contextual","fallback","extend","decodeArray","Type","array","out","stop","digit","Safety","verbose","process","LOG","stackIDs","cutAt","fullCursor","childAfter","Rec","FragmentCursor","fragment","safeFrom","safeTo","trees","nextFragment","fr","nextStart","TokenCache","tokens","mainToken","actions","tokenizers","actionIndex","main","tokenizer","updateCachedToken","addActions","setLookAhead","eofTerm","specialized","specializers","putAction","Parse","recovering","nextStackID","minStackPos","stoppedAt","topTerm","stacks","bufferLength","stopped","stoppedTokens","newStacks","advanceStack","tok","getMainToken","finished","findFinished","stackToTree","console","log","getName","SyntaxError","runRecovery","forceAll","maxRemaining","sort","a","outer","sameState","splice","stackID","strictCx","cxHash","cached","nodeAt","useNode","defaultReduce","getActions","localStack","apply","pushStackDedup","restarted","tokenEnd","deadEnd","restart","advanceFully","force","forceBase","recoverByInsert","insert","recoverByDelete","close","String","fromCodePoint","Dialect","disabled","LRParser","wrappers","version","nodeNames","repeatNodeCount","topTerms","keys","topRules","nodeProps","setProp","nodeID","propSpec","skippedNodes","tokenArray","tokenData","states","Uint32Array","stateData","maxTerm","dialects","dynamicPrecedences","tokenPrecTable","tokenPrec","termNames","parseDialect","w","loose","table","groupTag","terminal","slot","flag","prev","iPrev","findOffset","info","t","find","contextTracker","wrap","prec","values","part","Uint8Array"],"sourceRoot":""}